---
title: '事务和批处理查询'
metaTitle: '事务和批处理查询 (参考)'
metaDescription: '此页面解释 Prisma Client 的当前事务 API。'
---

<TopBlock>

数据库事务是指一系列读/写操作，这些操作作为一个整体 _保证_ 成功或失败。本节介绍 Prisma Client API 支持事务的方式。

- 有关更深入的示例和用例，请参阅📖 [事务指南](../../../guides/performance-and-optimization/prisma-client-transactions-guide)。
- 有关一般事务以及 Prisma 当前解决方案背后的原因的信息，请参阅✍ [博客：Prisma 如何支持事务](https://www.prisma.io/blog/how-prisma-supports-transactions-x45s1d5l0ww1/).

</TopBlock>

## 嵌套写入

[嵌套写入](relation-queries#nested-writes) 允许你使用多个 _操作_ 执行单个 Prisma Client API 调用，这些操作涉及多个 [_相关的_](../prisma-schema/relations) 记录。例如，创建 _用户_ 和 _post_ 或更新 _订单_ 和 _发票_。Prisma Client 确保所有操作作为一个整体成功或失败。

下面的示例演示了带有 `create` 的嵌套写入：

```ts
// 在一个事务中创建一个具有两个帖子的新用户
const newUser: User = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    posts: {
      create: [
        { title: 'Join the Prisma Slack on https://slack.prisma.io' },
        { title: 'Follow @prisma on Twitter' },
      ],
    },
  },
})
```

以下示例演示了带有 `update` 的嵌套写入：

```ts
// 在单个事务中更改帖子的作者
const updatedPost: Post = await prisma.post.update({
  where: { id: 42 },
  data: {
    author: {
      connect: { email: 'alice@prisma.io' },
    },
  },
})
```

> 更多示例请参考 📖 [事务指南](../../../guides/performance-and-optimization/prisma-client-transactions-guide#nested-writes)。

## 批处理/批量操作

以下批量操作作为事务运行：

- `deleteMany`
- `updateMany`
- `createMany`

> 更多示例请参考 📖 [事务指南](../../../guides/performance-and-optimization/prisma-client-transactions-guide#bulk-operations)。

## The <inlinecode>$transaction</inlinecode> API

以下查询返回与提供的过滤器匹配的所有帖子以及所有帖子的计数：

```ts
const [posts, totalPosts] = await prisma.$transaction([
  prisma.post.findMany({ where: { title: { contains: 'prisma' } } }),
  prisma.post.count(),
])
```

你可以在 `$transaction` 中使用 `$queryRaw` 和 `$executeRaw` ：

```ts
const [userList, updateUser] = await prisma.$transaction([
  prisma.$queryRaw`SELECT 'title' FROM User`,
  prisma.$executeRaw`UPDATE User SET name = 'Hello' WHERE id = 2;`,
])
```

操作本身不是在执行时立即等待每个操作的结果，而是先存储在变量中，然后通过名为 `$transaction` 的方法提交给数据库。Prisma Client 将确保所有三个 `create` 操作都成功，或者没有一个成功。

> **注意**：操作根据其在事务中的顺序执行。在事务中使用查询不会影响查询本身的操作顺序。

> 
> 参考📖 [事务指南](../../../guides/performance-and-optimization/prisma-client-transactions-guide#transaction-api) 了解更多示例。

### 交互式事务（在预览版）

有时，你需要更多地控制事务中执行的查询。

当一个查询的结果依赖于另一个查询，并且希望在单个事务中运行两个查询时，通常使用交互式事务。

为了支持此用例及更多，你可以通过在 Prisma Schema 的生成器中添加 `interactiveTransactions` 来启用交互式事务：

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["interactiveTransactions"]
}
```

然后你可以将异步函数传递到 [`$transaction`](../../../guides/performance-and-optimization/prisma-client-transactions-guide#transaction-api)。

以下是在线购买电影票的示例。在这个例子中，我们真的不想把同一张票卖两次：

```tsx
import { Ticket } from 'prisma'

const userEmail = 'alice@prisma.io'
const movieName = 'October Sky'

// 开始一个事务
const ticket: Ticket = await prisma.$transaction(async (prisma) => {
  // 找到一个可用的电影票
  const availableTicket = await prisma.ticket.findFirst({
    where: {
      claimedBy: null,
      movie: {
        name: movieName,
      },
    },
  })

  // 如果没有可用的电影票抛出一个异常
  if (!availableTicket) {
    // 事务将被回滚
    throw new Error(`Oh no! ${movieName} is all booked.`)
  }

  // 索取票据、提交事务并返回结果
  return prisma.ticket.update({
    data: {
      claimedBy: userEmail,
    },
    where: {
      id: availableTicket.id,
    },
  })
})
```

在上面的示例中，`findFirst` 和 `update` 查询都在数据库事务中运行。当应用程序到达函数末尾时，事务将 **提交** 到数据库。

如果应用程序在此过程中遇到错误，异步函数将抛出异常并自动 **回滚** 事务。

要捕获异常，可以在 try-catch 块中包含 `$transaction`：

```js
try {
  await prisma.$transaction(async (prisma) => {
    // 代码运行了一个事务...
  })
} catch (err) {
  // 处理回滚...
}
```

此外，事务 API 支持具有以下配置选项的第二个参数：

- `maxWait`:Prisma Client 等待从数据库获取事务的最长时间。默认值为 2 秒。

- `timeout`：在取消和回滚交互事务之前，可以运行的最长时间。默认值为 5 秒。

例如：

```jsx
await prisma.$transaction(
  async (prisma) => {
    // 代码运行了一个事务...
  },
  {
    maxWait: 5000, // default: 2000
    timeout: 10000, // default: 5000
  }
)
```

<Admonition type="warning">

**谨慎使用交互式事务**。
保持事务长时间打开会有损数据库性能，甚至可能导致死锁。
尽量避免执行网络请求和在内部执行缓慢的查询事务功能。
我们建议你尽可能的快进快出！

</Admonition>

## 事务隔离级别

当前无法在 Prisma 级别配置事务隔离级别，Prisma 也未显式设置事务隔离级别。

- [PostgreSQL 中的默认事务隔离级别](https://www.postgresql.org/docs/9.3/runtime-config-client.html#GUC-DEFAULT-TRANSACTION-ISOLATION)
- [SQL Server 中的默认事务隔离级别](https://docs.microsoft.com/en-us/sql/t-sql/statements/set-transaction-isolation-level-transact-sql?view=sql-server-ver15)
- [MySQL 中的默认事务隔离级别](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html)

## 加入 GitHub 上的对话

如果你希望看到将来支持的事务，[请加入关于 GitHub 的讨论](https://github.com/prisma/prisma-client-js/issues/349)。

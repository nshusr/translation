---
title: 'Prisma Client API 参考'
metaTitle: 'Prisma Client API (参考)'
metaDescription: 'Prisma Client API 参考文档'
tocDepth: 2
toc: true
---

<TopBlock>

Prisma Client API 参考文档是基于以下架构的：

```prisma
model User {
  id           Int              @id @default(autoincrement())
  name         String?
  email        String           @unique
  profileViews Int              @default(0)
  role         Role             @default(USER)
  coinflips    Boolean[]
  posts        Post[]
  city         String
  country      String
  profile      ExtendedProfile?
  pets         Json
}

model ExtendedProfile {
  id     Int     @id @default(autoincrement())
  userId Int?    @unique
  bio    String?
  User   User?   @relation(fields: [userId], references: [id])
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  published Boolean @default(true)
  author    User    @relation(fields: [authorId], references: [id])
  authorId  Int
  comments  Json
  views     Int     @default(0)
  likes     Int     @default(0)
}

enum Role {
  USER
  ADMIN
}
```

所有生成的示例类型（如`UserSelect`和`UserWhereUniqueInput`）都基于`User`模型。

</TopBlock>

## <inlinecode>PrismaClient</inlinecode>

这一小节描述了`PrismaClient`构造函数和其参数。

### 备注

- 参数是在运行时进行验证。

### <inlinecode>数据源(datasource)</inlinecode>

修改`schema.prisma`文件中的`datasource`部分 - 例如，作为一个集成测试的一部分。参见[数据源](../../../concepts/components/prisma-schema/data-sources) <span class="concept"></span>

#### 属性

| 属性 | 值                            | 描述                                                      |
| ---- | ----------------------------- | --------------------------------------------------------- |
| `db` | `{ url: 'file:./dev_qa.db' }` | 数据库 [连接地址](../database-reference/connection-urls). |

#### 备注

- 每次添加或重命名数据源时，都需要重新生成 Prisma Client。数据源名称包含在生成的客户端中。
- 如果你往 schema 中添加了一个新的数据源，那么你需要重新生成客户端。

#### 例子

##### 修改 数据源(datasource) `url`

```ts
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  datasources: {
    db: {
      url: 'file:./dev_qa.db',
    },
  },
})
```

基于以下`datasource`代码:

```prisma
datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}
```

### <inlinecode>日志</inlinecode>

确定日志类型和级别。参见[日志](../../../concepts/components/prisma-client/working-with-prismaclient/logging) <span class="concept"></span>

#### 选项

| 选项     | 例子                                                                     | 描述 |
| -------- | ------------------------------------------------------------------------ | ---- |
| 日志级别 | `[ "info", "query" ]`                                                    |      |
| 定义级别 | `[ { level: "info", emit: "event" }, { level: "warn", emit: "stdout" }]` |      |

##### 日志级别

| 名称    | 例子                                                                                                                                                                                                                                                                                                                     |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `query` | 例子: <br />`prisma:query SELECT "public"."User"."id", "public"."User"."email" FROM "public"."User" WHERE ("public"."User"."id") IN (SELECT "t0"."id" FROM "public"."User" AS "t0" INNER JOIN "public"."Post" AS "j0" ON ("j0"."authorId") = ("t0"."id") WHERE ("j0"."views" > $1 AND "t0"."id" IS NOT NULL)) OFFSET $2` |
| `info`  | 例子: <br />`prisma:info Started http server on http://127.0.0.1:58471`                                                                                                                                                                                                                                                  |
| `warn`  | 警告。                                                                                                                                                                                                                                                                                                                   |
| `error` | 错误。                                                                                                                                                                                                                                                                                                                   |

##### 触发格式

| 名称     | 描述                                                           |
| -------- | -------------------------------------------------------------- |
| `stdout` | 参见: [stdout](https://en.wikipedia.org/wiki/Standard_streams) |
| `event`  | 触发你可以订阅的事件。                                         |

#### 参考

```ts file=index.d.ts
log?: Array<LogLevel | LogDefinition>
```

```ts file=index.d.ts
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}
```

##### 事件类型

`query` 类型:

```ts file=index.d.ts
export type QueryEvent = {
  timestamp: Date
  query: string // 查询发送到数据库
  params: string // 查询参数
  duration: number // 客户端发送查询到数据库的时间间隔 - 不仅是执行查询所需的时间
  target: string
}
```

其他日志级别事件类型:

```ts file=index.d.ts
export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
```

#### 例子

##### 将 `query` 和 `info` 日志记录到 `stdout`

<CodeWithResult>

<cmd>

```ts highlight=3;normal;
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({ log: ['query', 'info'] })

async function main() {
  const countUsers = await prisma.user.count({})
}

main()
  .catch((e) => {
    throw e
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

</cmd>

<cmdResult>

```
prisma:info  Starting a postgresql pool with 13 connections.
prisma:info  Started http server
prisma:query SELECT COUNT(*) FROM (SELECT "public"."User"."id" FROM "public"."User" WHERE 1=1 ORDER BY "public"."User"."coinflips" ASC OFFSET $1) AS "sub"
```

</cmdResult>

</CodeWithResult>

##### 将 `query` 事件记录到控制台

<CodeWithResult>
<cmd>

```ts
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: [{ level: 'query', emit: 'event' }],
})

prisma.$on('query', (e) => {
  console.log(e)
})

async function main() {
  const countUsers = await prisma.user.count({})
}

main()
  .catch((e) => {
    throw e
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

</cmd>

<cmdResult>

```js
{
  timestamp: 2020-11-17T10:32:10.898Z,
  query: 'SELECT COUNT(*) FROM (SELECT "public"."User"."id" FROM "public"."User" WHERE 1=1 OFFSET $1) AS "sub"',
  params: '[0]',
  duration: 5,
  target: 'quaint::connector::metrics'
}
```

</cmdResult>

</CodeWithResult>

##### 将 `info`, `warn`, 和 `error` 事件记录到控制台

<CodeWithResult>
<cmd>

```ts
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: [
    { level: 'warn', emit: 'event' },
    { level: 'info', emit: 'event' },
    { level: 'error', emit: 'event' },
  ],
})

prisma.$on('warn', (e) => {
  console.log(e)
})

prisma.$on('info', (e) => {
  console.log(e)
})

prisma.$on('error', (e) => {
  console.log(e)
})

async function main() {
  const countUsers = await prisma.user.count({})
}

main()
  .catch((e) => {
    throw e
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

</cmd>
<cmdResult>

```js
{
  timestamp: 2020-11-17T10:33:24.592Z,
  message: 'Starting a postgresql pool with 13 connections.',
  target: 'quaint::pooled'
}
{
  timestamp: 2020-11-17T10:33:24.637Z,
  message: 'Started http server',
  target: 'query_engine::server'
}
```

</cmdResult>
</CodeWithResult>

### <inlinecode>错误格式化</inlinecode>

确定 Prisma 返回的错误级别和格式。

#### 格式化

| 名称                  | 描述                       |
| --------------------- | -------------------------- |
| `undefined`           | 如果未定义，则默认为无色。 |
| `pretty`              | 开启 pretty 格式化。       |
| `colorless` (default) | 开启 colorless 格式化。    |
| `minimal`             | 开启 minimal 格式化。      |

#### 参考

```ts file=index.d.ts
errorFormat?: ErrorFormat
```

```ts file=index.d.ts
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
```

#### 例子

##### 不设置格式

```ts
const prisma = new PrismaClient({
  // 默认使用 colorless 格式
})
```

##### `pretty` 格式

```ts
const prisma = new PrismaClient({
  errorFormat: 'pretty',
})
```

##### `colorless` 格式

```ts
const prisma = new PrismaClient({
  errorFormat: 'colorless',
})
```

##### `minimal` 格式

```ts
const prisma = new PrismaClient({
  errorFormat: 'minimal',
})
```

### <inlinecode>rejectOnNotFound</inlinecode>

使用 `rejectOnNotFound` 参数配置 `findUnique` 和/或 `findFirst` 如果记录未找到，则抛出错误。默认情况下。两个操作都返回 `null`。

### 备注

- 你可以配置 `rejectOnNotFound` 在每个请求级别，对于 [`findUnique`](#findunique) 和 [`findFirst`](#findfirst)

#### 选项

| 选项                 | 描述                                                                                      |
| -------------------- | ----------------------------------------------------------------------------------------- |
| `RejectOnNotFound`   | 全局启用 (`true` / `false`) _或_ 抛出一个自定义错误。                                     |
| `RejectPerOperation` | 全局启用在操作前开启 (`true` / `false`) _或_ 每个操作前抛出一个自定义错误，按模型(Model). |

#### 参考

```ts file=index.d.ts
rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
```

#### 例子

##### 全局启用 `findUnique` 和 `findFirst`

```ts
const prisma = new PrismaClient({
  rejectOnNotFound: true,
})
```

##### 为特定操作全局启用

```ts
const prisma = new PrismaClient({
  rejectOnNotFound: {
    findUnique: true,
  },
})
```

##### 如果未找到记录，则为每个模型和操作抛出自定义错误

```ts
const prisma = new PrismaClient({
  rejectOnNotFound: {
    findFirst: {
      User: (err) => new Error('User error'),
      Post: (err) => new Error('Post error!'),
    },
    findUnique: {
      User: (err) => new Error('User error'),
      Post: (err) => new Error('Post error!'),
    },
  },
})
```

## 模型查询 (Model queries)

使用模型查询来执行 CRUD 操作。参见 [CRUD](../../../concepts/components/prisma-client/crud) <span class="concept"></span>

### <inlinecode>findUnique</inlinecode>

`findUnique` 查询 使用唯一条件来获取单个数据库记录：

- 按 _ID_
- 按 _唯一_(_unique_) 属性

`findUnique` 替代 `findOne` 在 [2.12.0](https://github.com/prisma/prisma/releases/tag/2.12.0) 版本后。

#### 备注

- Prisma 的 `dataloader` [自动批处理 `findUnique` 查询](../../guides/performance-and-optimization/query-optimization-performance#solving-n1-in-graphql-with-findunique-and-prismas-dataloader) 具有相同的 `select` 和 `where` 参数

#### 选项

| 名称               | 示例类型 (`User`)        | 必填   | 描述                                                                                                                       |
| ------------------ | ------------------------ | ------ | -------------------------------------------------------------------------------------------------------------------------- |
| `where`            | `UserWhereUniqueInput`   | **是** | 包含模型的所有唯一字段，以便可以选择各个记录。                                                                             |
| `select`           | `XOR<UserSelect, null>`  | 否     | 指定返回的对象[要包含的属性](../../concepts/components/prisma-client/select-fields)。                                      |
| `include`          | `XOR<UserInclude, null>` | 否     | 指定返回的对象[要加载的关系](../../concepts/components/prisma-client/relation-queries)。                                   |
| `rejectOnNotFound` | `RejectOnNotFound`       | 否     | 如果为 true, 抛出一个 `NotFoundError: No User found error`. 你也可以 [配置开启全局 `rejectOnNotFound`](#rejectonnotfound). |

#### 返回类型

| 返回类型                  | 例子                       | 描述                                                                                                                              |
| ------------------------- | -------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| JavaScript object (typed) | `User`                     |                                                                                                                                   |
| JavaScript object (plain) | `{ title: "Hello world" }` | 使用 `select` 和 `include` 来确定要返回的字段                                                                                     |
| `null`                    | `null`                     | 未找到记录                                                                                                                        |
| Error                     |                            | 如果 `rejectOnNotFound` 为 true, `findUnique` 则抛出错误 (`NotFoundError` 为默认, [可全局自定义](#rejectonnotfound)) 返回 `null`. |

#### 参考

`findUnique` 接受以下输入类型:

```ts file=index.d.ts
export type UserFindUniqueArgs = {
  where: UserWhereUniqueInput
  select?: UserSelect | null
  include?: UserInclude | null
}
```

#### 例子

##### 获取 `id` 为 `42` 的 `User` 记录

```ts
const result = await prisma.user.findUnique({
  where: {
    id: 42,
  },
})
```

##### 获取 `email` 为 `alice@prisma.io` 的 `User` 记录

```ts
const result = await prisma.user.findUnique({
  where: {
    email: 'alice@prisma.io',
  },
})
```

##### 获取 `firstName` 为 `Alice` 并且 `lastName` 为 `Smith` (`@@unique`) 的 `User` 记录

<details><summary>展开示例：User 模型使用 @@unique</summary>

```prisma
model User {
  firstName String
  lastName  String

  @@unique(fields: [firstName, lastName], name: "fullname")
}
```

</details>

```ts
const result = await prisma.user.findUnique({
  where: {
    fullname: {
      // name 属性的 @@unique 属性 - 默认为 firstname_lastname
      firstName: 'Alice',
      lastName: 'Smith',
    },
  },
})
```

##### 获取 `firstName` 为 `Alice` 并且 `lastName` 为 `Smith` (`@@id`) 的 `User` 记录

<details><summary>展开示例 User 模型为使用 @@id</summary>

```prisma
model User {
  firstName String
  lastName  String

  @@id([firstName, lastName])
}
```

</details>

```ts
const result = await prisma.user.findUnique({
  where: {
    firstName_lastName: {
      firstName: 'Alice',
      lastName: 'Smith',
    },
  },
})
```

### <inlinecode>findFirst</inlinecode>

`findFirst` 返回第一个匹配您的条件的记录。

#### 选项

| 名称               | 示例类型 (`User`)                                            | 必填 | 描述                                                                                                                                                  |
| ------------------ | ------------------------------------------------------------ | ---- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| `distinct`         | `Enumerable<UserDistinct`<br />`FieldEnum>`                  | 否   | 允许您按特定的字段来过滤掉重复的行。 - 例如仅返回不同标题的“帖子”。                                                                                   |
| `where`            | `UserWhereInput`                                             | 否   | 将模型所有字段包装在一个类型中，以便可以通过任何属性过滤列。表。                                                                                      |
| `cursor`           | `UserWhereUniqueInput`                                       | 否   | 指定列表的位置（该值通常指定一个 `id` 或其他唯一值）。                                                                                                |
| `orderBy`          | `XOR<Enumerable<User`<br />`OrderByInput>,UserOrderByInput>` | 否   | 允许您按任何属性对返回的列表进行排序。                                                                                                                |
| `include`          | `XOR<UserInclude, null>`                                     | 否   | [指定急切加载哪些关系](../../concepts/components/prisma-client/relation-queries) 在返回的对象上。                                                     |
| `select`           | `XOR<UserSelect, null>`                                      | 否   | [指定要包含的属性](../../concepts/components/prisma-client/select-fields) 在返回的对象上。                                                            |
| `skip`             | `number`                                                     | 否   | 指定应跳过列表中返回的对象的数量。                                                                                                                    |
| `take`             | `number`                                                     | 否   | 指定应在列表中返回多少个对象。当与 `findFirst` 一起使用时，`take` 隐式为 `1` 或 `-1`。 `findFirst` 仅受值是正值还是负值的影响 -任何负值都会反转列表。 |
| `rejectOnNotFound` | `RejectOnNotFound`                                           | 否   | 如果为 true, 则抛出“NotFoundError: No User found error”。 您还可以[全局配置`rejectOnNotFound`](#rejectonnotfound)。                                   |

#### 返回类型

| 返回类型                  | 例子                       | 描述                                                                                                                                                 |
| ------------------------- | -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| JavaScript object (typed) | `User`                     | 指定要在返回的对象上包含哪些属性。                                                                                                                   |
| JavaScript object (plain) | `{ title: "Hello world" }` | 使用 `select` 和 `include` 来确定要返回的字段。                                                                                                      |
| `null`                    | `null`                     | 记录不存在                                                                                                                                           |
| Error                     |                            | 如果 `rejectOnNotFound` 为 true，`findUnique` 会抛出一个错误（默认情况下为 `NotFoundError`，[全局可自定义](#rejectonnotfound)），而不是返回 `null`。 |

#### 注意

- `findFirst` 在幕后调用 `findMany` 并接受相同的查询选项。
- 当您使用 `findFirst` 查询时传递一个负的 `take` 值会颠倒列表的顺序。

#### 参考

`findFirst` 接受以下输入类型:

```ts file=index.d.ts
export type UserFindFirstArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  rejectOnNotFound?: RejectOnNotFound
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}
```

#### 例子

参见[过滤条件和运算符](#filter-conditions-and-operators)以例子查看过滤结果。

##### 获取 `name` 字段为 `Alice` 的第一个 `User` 记录

```ts
const user = await prisma.user.findFirst({
  where: { name: 'Alice' },
})
```

##### 获取 `title` 字段以 `A test` 开头的第一个 `Post` 记录，并反转列表（`take`）

```ts
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({})

async function main() {
  const a = await prisma.post.create({
    data: {
      title: 'A test 1',
    },
  })

  const b = await prisma.post.create({
    data: {
      title: 'A test 2',
    },
  })

  const c = await prisma.post.findFirst({
    where: {
      title: {
        startsWith: 'A test',
      },
    },
    orderBy: {
      title: 'asc',
    },
    take: -1, // 反转列表
  })
}

main()
```

### <inlinecode>findMany</inlinecode>

<AlgoliaTerm name="apiReference" value="findMany" />

`findMany` 接受一个查询选项，并返回一个列表。

#### 选项

| 名称       | 类型                                                          | 必填 | 描述                                                                                                                   |
| ---------- | ------------------------------------------------------------- | ---- | ---------------------------------------------------------------------------------------------------------------------- |
| `where`    | `UserWhereInput`                                              | 否   | 将模型所有字段包装在一个类型中，以便可以通过任何属性过滤列。表。                                                       |
| `orderBy`  | `XOR<Enumerable<PostOrder`<br />`ByInput>, PostOrderByInput>` | 否   | 允许您按任何属性对返回的列表进行排序。                                                                                 |
| `skip`     | `number`                                                      | 否   | 指定应跳过列表中返回的对象的数量。                                                                                     |
| `cursor`   | `UserWhereUniqueInput`                                        | 否   | 指定列表开始的位置（该值通常指定一个 id 或其他唯一值）。                                                               |
| `take`     | `number`                                                      | 否   | 指定在列表中应该返回多少个对象（从列表的**开头**（正值）或**结尾**（负值）来看，或者从 `cursor` 位置（如果提到的话）。 |
| `select`   | `XOR<PostSelect, null>`                                       | 否   | [指定要包含的属性](../../concepts/components/prisma-client/select-fields) 在返回的对象上。                             |
| `include`  | `XOR<PostInclude, null>`                                      | 否   | [指定急切加载哪些关系](../../concepts/components/prisma-client/relation-queries) 在返回的对象上。                      |
| `distinct` | `Enumerable<UserDistinctFieldEnum>`                           | 否   | 允许您按特定的字段来过滤掉重复的行。 - 例如仅返回不同标题的“帖子”。                                                    |

#### 返回类型

| 返回类型                        | 例子                         | 描述                                            |
| ------------------------------- | ---------------------------- | ----------------------------------------------- |
| JavaScript array object (typed) | `User[]`                     |                                                 |
| JavaScript array object (plain) | `[{ title: "Hello world" }]` | 使用 `select` 和 `include` 来确定要返回的字段。 |
| Empty array                     | `[]`                         | 没有找到匹配的记录。                            |

#### 参考

`findMany` 接受以下输入类型:

```ts file=index.d.ts
export type UserFindManyArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}
```

#### 例子

参见 [过滤条件和运算符](#filter-conditions-and-operators) 以获取更多示例。

##### 获取所有 `User` 记录，其中 `name` 字段的值为 `Alice`

```ts
const user = await prisma.user.findMany({
  where: { name: 'Alice' },
})
```

### <inlinecode>create</inlinecode>

`create` 创建一个新的数据库记录。

#### 选项

| 名称                  | 类型                                                     | 必填   | 描述                                                                                                                                                           |
| --------------------- | -------------------------------------------------------- | ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`                | `XOR<UserCreateInput,` <br />`UserUncheckedCreateInput>` | **是** | 将所有模型字段包装在一个类型中，以便在创建新记录时提供它们。它还包括允许您执行（事务性）嵌套插入的关系字段。在数据模型中标记为可选或具有默认值的字段是可选的。 |
| [`select`](#select)   | `XOR<UserSelect, null>`                                  | 否     | [指定要包含的属性](../../concepts/components/prisma-client/select-fields) 在返回的对象上。                                                                     |
| [`include`](#include) | `XOR<UserInclude, null>`                                 | 否     | [指定应急切加载哪些关系](../../concepts/components/prisma-client/relation-queries) 在返回的对象上。                                                            |

#### 返回类型

| 返回类型                  | 例子                           | 描述                                            |
| ------------------------- | ------------------------------ | ----------------------------------------------- |
| JavaScript object (typed) | `User`                         |                                                 |
| JavaScript object (plain) | `{ name: "Alice Wonderland" }` | 使用 `select` 和 `include` 来确定要返回的字段。 |

#### 注意

- 你可以使用 [`create`](#create-1) 来创建一个嵌套的记录。例如，你可以同时创建一个 `User` 和两个 `Post` 记录。

#### 参考

`create` 接受以下输入类型:

```ts file=index.d.ts
export type UserCreateArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  data: XOR<UserCreateInput, UserUncheckedCreateInput>
}
```

#### 例子

##### 创建一个只有 `email` 字段的新记录

```ts
const user = await prisma.user.create({
  data: { email: 'alice@prisma.io' },
})
```

##### 创建多个新记录

Prisma Client 不支持在数据库级别批量插入。请查看 [issue #332 on GitHub](https://github.com/prisma/prisma-client-js/issues/332) 更新。

以下示例结果产生 **两个** `INSERT` 方法:

<CodeWithResult expanded={true}>

<cmd>

```ts
import { PrismaClient, UserCreateInput } from '@prisma/client'

const prisma = new PrismaClient({ log: ['query'] })

async function main() {
  let users: UserCreateInput[] = [
    {
      email: 'ariana@prisma.io',
      name: 'Ari',
      profileViews: 20,
      coinflips: [true, false, false],
      role: 'ADMIN',
    },
    {
      email: 'elsa@prisma.io',
      name: 'Elsa',
      profileViews: 20,
      coinflips: [true, false, false],
      role: 'ADMIN',
    },
  ]

  await Promise.all(
    users.map(async (user) => {
      await prisma.user.create({
        data: user,
      })
    })
  )
}

main()
  .catch((e) => {
    throw e
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

</cmd>

<cmdResult>

```sql
prisma:query BEGIN
prisma:query INSERT INTO "public"."User" ("name","email","profileViews","role","coinflips") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
prisma:query SELECT "public"."User"."id", "public"."User"."name", "public"."User"."email", "public"."User"."profileViews", "public"."User"."role", "public"."User"."coinflips" FROM "public"."User" WHERE "public"."User"."id" = $1 LIMIT $2 OFFSET $3
prisma:query INSERT INTO "public"."User" ("name","email","profileViews","role","coinflips") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
prisma:query COMMIT
prisma:query SELECT "public"."User"."id", "public"."User"."name", "public"."User"."email", "public"."User"."profileViews", "public"."User"."role", "public"."User"."coinflips" FROM "public"."User" WHERE "public"."User"."id" = $1 LIMIT $2 OFFSET $3
prisma:query COMMIT
```

</cmdResult>

</CodeWithResult>

### <inlinecode>update</inlinecode>

`update` 更新现有的数据库记录。

#### 选项

| 名称                  | 类型                                                   | 必填   | 描述                                                                                                     |
| --------------------- | ------------------------------------------------------ | ------ | -------------------------------------------------------------------------------------------------------- |
| `data`                | `XOR<UserUpdateInput`<br />`UserUncheckedUpdateInput>` | **是** | 包装模型的所有字段，以便在更新现有记录时可以提供它们。在数据模型中标记为可选或具有默认值的字段是可选的。 |
| `where`               | `UserWhereUniqueInput`                                 | **是** | 包装模型的所有 _unique_ 字段，以便可以选择单个记录。                                                     |
| [`select`](#select)   | `XOR<UserSelect, null>`                                | 否     | [指定要包含的属性](../../concepts/components/prisma-client/select-fields) 在返回的对象上。               |
| [`include`](#include) | `XOR<UserInclude, null>`                               | 否     | [指定应急切加载哪些关系](../../concepts/components/prisma-client/relation-queries) 在返回的对象上。      |

#### 返回类型

| 返回类型                   | 例子                           | 描述                                            |
| -------------------------- | ------------------------------ | ----------------------------------------------- |
| JavaScript object (typed)  | `User`                         |                                                 |
| JavaScript object (plain)  | `{ name: "Alice Wonderland" }` | 使用 `select` 和 `include` 来确定要返回的字段。 |
| `RecordNotFound` exception |                                | 如果记录不存在则抛出异常。                      |

#### 注意

- 要对更新（加、减、乘、除）执行算术运算，请使用 [原子更新(atomic updates)](#atomic-number-operations) 来防止竞争条件。
- 您还可以执行嵌套的 [`update`](#update-1) -例如，同时更新用户和该用户的帖子。

#### 参考

```ts file=index.d.ts
export type UserUpdateArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  where: UserWhereUniqueInput
}
```

#### 例子

##### 将 `id` 为 `1` 的 `User` 记录的 `email` 更新为 `alice@prisma.io`

```ts
const user = await prisma.user.update({
  where: { id: 1 },
  data: { email: 'alice@prisma.io' },
})
```

### <inlinecode>upsert</inlinecode>

`upsert` 更新现有的*或*创建新的数据库记录。

#### 选项

| 名称                  | 类型                                                    | 必填   | 描述                                                                                                                                               |
| --------------------- | ------------------------------------------------------- | ------ | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| `create`              | `XOR<UserCreateInput,`<br />`UserUncheckedCreateInput>` | **是** | 包装模型的所有字段，以便在创建新记录时提供它们。它还包括允许您执行（事务性）嵌套插入的关系字段。在数据模型中标记为可选或具有默认值的字段是可选的。 |
| `update`              | `XOR<UserUpdateInput,`<br />`UserUncheckedUpdateInput>` | **是** | 包装模型的所有字段，以便在更新现有记录时可以提供它们。在数据模型中标记为可选或具有默认值的字段是可选的。                                           |
| `where`               | `UserWhereUniqueInput`                                  | **是** | 包装模型的所有 _unique_ 字段，以便可以选择单个记录。                                                                                               |
| [`select`](#select)   | `XOR<UserSelect, null>`                                 | 否     | [指定要包含的属性](../../concepts/components/prisma-client/select-fields) 在返回的对象上。                                                         |
| [`include`](#include) | `XOR<UserInclude, null>`                                | 否     | [指定应急切加载哪些关系](../../concepts/components/prisma-client/relation-queries) 在返回的对象上。                                                |

#### 返回类型

| 返回类型                  | 例子                           | 例子                                            |
| ------------------------- | ------------------------------ | ----------------------------------------------- |
| JavaScript object (typed) | `User`                         |                                                 |
| JavaScript object (plain) | `{ name: "Alice Wonderland" }` | 使用 `select` 和 `include` 来确定要返回的字段。 |

#### 注意

- 要对更新（加、减、乘、除）执行算术运算，请使用 [原子更新(atomic updates)](#atomic-number-operations) 来防止竞争条件。

#### 参考

`upsert` 接受以下输入类型:

```ts file=index.d.ts
export type UserUpsertArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where: UserWhereUniqueInput
  create: XOR<UserCreateInput, UserUncheckedCreateInput>
  update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
}
```

#### 例子

##### 更新（如果存在）或创建一个 `email` 为 `alice@prisma.io` 的 `User` 记录

```ts
const user = await prisma.user.upsert({
  where: { id: 1 },
  update: { email: 'alice@prisma.io' },
  create: { email: 'alice@prisma.io' },
})
```

### <inlinecode>delete</inlinecode>

`delete` 删除现有的数据库记录。您可以删除记录:

- 按 _ID_
- 按一个 _unique_ 属性

要删除符合特定条件的记录，请使用带过滤器的 [`deleteMany`](#deleteMany)。

#### 选项

| 名称                  | 类型                     | 必填   | 描述                                                                                                |
| --------------------- | ------------------------ | ------ | --------------------------------------------------------------------------------------------------- |
| `where`               | `UserWhereUniqueInput`   | **是** | 包装模型的所有 _unique_ 字段，以便可以选择单个记录。                                                |
| [`select`](#select)   | `XOR<UserSelect, null>`  | 否     | [指定要包含的属性](../../concepts/components/prisma-client/select-fields) 在返回的对象上。          |
| [`include`](#include) | `XOR<UserInclude, null>` | 否     | [指定应急切加载哪些关系](../../concepts/components/prisma-client/relation-queries) 在返回的对象上。 |

#### 返回类型

| 返回类型                  | 例子                           | 描述                                                                           |
| ------------------------- | ------------------------------ | ------------------------------------------------------------------------------ |
| JavaScript object (typed) | `User`                         | 被删除的 `User` 记录。                                                         |
| JavaScript object (plain) | `{ name: "Alice Wonderland" }` | 数据来自已删除的 `User` 记录。 使用 `select` 和 `include` 来确定要返回的字段。 |
| `RecordNotFound` 异常     |                                | 如果记录不存在则抛出异常。                                                     |

#### 注意

- 要根据某些条件删除多条记录（例如，所有带有 `prisma.io` 电子邮件地址的 `User` 记录，请使用 `deleteMany`）

#### 参考

`delete` 接受以下输入类型:

```ts file=index.d.ts
export type UserDeleteArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where: UserWhereUniqueInput
}
```

#### 例子

##### 删除 `id` 为 `1` 的 `User` 记录

```ts
const user = await prisma.user.delete({
  where: { id: 1 },
})
```

##### 删除 `email` 为 `else@prisma.io` 的 `User` 记录

以下查询会删除特定用户记录并使用 `select` 返回被删除用户的 `name` 和 `email`：

<CodeWithResult expanded="{true}">

<cmd>

```ts
const deleteUser = await prisma.user.delete({
  where: {
    email: 'elsa@prisma.io',
  },
  select: {
    email: true,
    name: true,
  },
})
```

</cmd>

<cmdResult>

```json
{ "email": "elsa@prisma.io", "name": "Elsa" }
```

</cmdResult>

</CodeWithResult>

### <inlinecode>createMany</inlinecode>

`createMany` 在一个事务中创建多个记录。

#### 选项

| 名称              | 类型                              | 必填   | 描述                                                                                                                                                            |
| ----------------- | --------------------------------- | ------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`            | `Enumerable<UserCreateManyInput>` | **是** | 将所有模型字段包装在一个类型中，以便在创建新记录时提供它们。它还包括允许您执行（事务性）嵌套插入的关系字段。在数据模型中标记为可选或具有默认值的字段是可选的。  |
| `skipDuplicates?` | `boolean`                         | 否     | 不要插入具有唯一字段或已存在的 ID 字段的记录。仅受支持的数据库支持 [`在冲突中什么都不做`](https://www.postgresql.org/docs/9.5/sql-insert.html#SQL-ON-CONFLICT). |

#### 返回类型

| 返回类型       | 例子           | 描述                 |
| -------------- | -------------- | -------------------- |
| `BatchPayload` | `{ count: 3 }` | 创建的记录的总条数。 |

#### 注意

- `createMany` 不支持 SqLite。
- 你 **不能** 创建或连接关系 - 你不能在一个顶级 `createMany` 中嵌套 `create`, `createMany`, `connect`, `connectOrCreate`。
- 你可以在一个 [`createMany`](#createmany-1) 中嵌套多个 `create` 或 `update` 查询 - 例如，在同一个 `createMany` 中添加一个 `User` 和两个 `Post` 记录。

#### 参考

`createMany` 接受以下输入类型:

```ts file=index.d.ts
export type UserCreateManyArgs = {
  data: Enumerable<UserCreateManyInput>
  skipDuplicates?: boolean
}
```

#### 例子

##### 创建一些新用户

```ts
const users = await prisma.user.createMany({
  data: [
    { name: 'Sonali', email: 'sonali@prisma.io' },
    { name: 'Alex', email: 'alex@prisma.io' },
  ],
})
```

### <inlinecode>updateMany</inlinecode>

`updateMany` 更新一批已存在的数据库记录并返回更新的记录数。

#### 选项

| 名称    | 类型                                                                    | 必填   | 描述                                                                                                                 |
| ------- | ----------------------------------------------------------------------- | ------ | -------------------------------------------------------------------------------------------------------------------- |
| `data`  | `XOR<UserUpdateManyMutationInput,`<br />`UserUncheckedUpdateManyInput>` | **是** | 包装模型的所有字段，以便在更新现有记录时可以提供它们。在数据模型中标记为可选或具有默认值的字段在 `data` 上是可选的。 |
| `where` | `UserWhereInput`                                                        | 否     | 包装模型的 _所有_ 字段，以便可以通过任何属性过滤列表。如果您不过滤列表，所有记录都将被更新。                         |

#### 返回类型

| 返回类型       | 例子           | 描述               |
| -------------- | -------------- | ------------------ |
| `BatchPayload` | `{ count: 4 }` | 更新记录的总条数。 |

```ts
export type BatchPayload = {
  count: number
}
```

#### 参考

`updateMany` 接受以下输入类型:

```ts file=index.d.ts
export type UserUpdateManyArgs = {
  data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
  where?: UserWhereInput
}
```

#### 例子

##### 将所有 `name` 字段为 `Alice` 的 `User` 的 `name` 更新为 `ALICE`

```ts
const updatedUserCount = await prisma.user.updateMany({
  where: { name: 'Alice' },
  data: { name: 'ALICE' },
})
```

##### 更新所有 `email` 包含 `prisma.io` 且 `Post`的 likes 大于 10 的所有 `用户` 记录。

```ts
const deleteUser = await prisma.user.updateMany({
  where: {
    email: {
      contains: 'prisma.io',
    },
    posts: {
      some: {
        likes: {
          gt: 10,
        },
      },
    },
  },
  data: {
    role: 'USER',
  },
})
```

### <inlinecode>deleteMany</inlinecode>

`deleteMany` deletes multiple records in a transaction.

#### 选项

| 名称    | 类型             | 必填 | 描述                                                |
| ------- | ---------------- | ---- | --------------------------------------------------- |
| `where` | `UserWhereInput` | 否   | 包装模型的 _all_ 字段，以便可以按任何字段过滤列表。 |

#### 返回类型

| 返回类型       | 例子           | 描述             |
| -------------- | -------------- | ---------------- |
| `BatchPayload` | `{ count: 4 }` | 更新记录的条数。 |

```ts
export type BatchPayload = {
  count: number
}
```

#### 参考

`deleteMany` 接受以下输入类型:

```ts file=index.d.ts
export type UserDeleteManyArgs = {
  where?: UserWhereInput
}
```

#### 例子

##### 删除所有 `User` 记录

```ts
const deletedUserCount = await prisma.user.deleteMany({})
```

##### 删除所有 `name` 为 `Alice` 的 `User` 记录

```ts
const deletedUserCount = await prisma.user.deleteMany({
  where: { name: 'Alice' },
})
```

有关如何过滤要删除的记录的示例，请参阅[过滤条件和运算符](#filter-conditions-and-operators)。

### <inlinecode>count</inlinecode>

#### 选项

| 名称       | 类型                                                          | 必填 | 描述                                                                                                                                                                                                      |
| ---------- | ------------------------------------------------------------- | ---- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`    | `UserWhereInput`                                              | 否   | Wraps _all_ model fields in a type so that the list can be filtered by any property.                                                                                                                      |
| `cursor`   | `UserWhereUniqueInput`                                        | 否   | 指定列表的位置（该值通常指定一个 `id` 或另一个唯一值）。                                                                                                                                                  |
| `skip`     | `number`                                                      | 否   | Specifies how many of the returned objects in the list should be skipped.                                                                                                                                 |
| `take`     | `number`                                                      | 否   | Specifies how many objects should be returned in the list (as seen from the _beginning_ (positive value) or _end_ (negative value) **either** of the list **or** from the `cursor` position if mentioned) |
| `orderBy`  | `XOR<Enumerable<PostOrder`<br />`ByInput>, PostOrderByInput>` | 否   | Lets you order the returned list by any property.                                                                                                                                                         |
| `distinct` | `Enumerable<UserDistinctFieldEnum>`                           | 否   | Lets you filter out duplicate rows by a specific field - for example, return only distinct `Post` titles.                                                                                                 |
| `select`   | `UserCountAggregateInputType`                                 | 否   | Select which fields to count (non-`null` values) - you can also count `_all`.                                                                                                                             |

#### 返回类型

| 返回类型                       | 例子                     | Description                   |
| ------------------------------ | ------------------------ | ----------------------------- |
| `number`                       | `29`                     | The count of records.         |
| `UserCountAggregateOutputType` | `{ _all: 27, name: 10 }` | Returned if `select` is used. |

#### 参考

`count` 接受以下输入类型:

```ts file=index.d.ts
export type UserFindManyArgs = {
  // select and include are excluded
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}

export type UserCountAggregateOutputType = {
  id: number
  name: number | null
  email: number | null
  profileViews: number
  role: number | null
  coinflips: number | null
  testing: number | null
  city: number | null
  country: number | null
  _all: number
}
```

#### 例子

##### Count all `User` records

```ts
const result = await prisma.user.count()
```

##### Count all `User` records with at least one published `Post`

```ts
const result = await prisma.user.count({
  where: {
    post: {
      some: {
        published: true,
      },
    },
  },
})
```

##### Use `select` to perform three separate counts

The following query returns:

- A count of all records (`_all`)
- A count of all records with non-`null` `name` fields
- A count of all records with non-`null` `city` fields

```ts
const c = await prisma.user.count({
  select: {
    _all: true,
    city: true,
    name: true,
  },
})
```

### <inlinecode>aggregate</inlinecode>

See also: [Aggregation, grouping, and summarizing](../../../concepts/components/prisma-client/aggregation-grouping-summarizing#aggregate) <span class="concept"></span>

#### 选项

| Name       | Type                                                         | Required | Description                                                                                                                                                                                               |
| ---------- | ------------------------------------------------------------ | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`    | `UserWhereInput`                                             | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                                                                                                                      |
| `orderBy`  | `XOR<Enumerable<UserOrderByInput>,`<br />`UserOrderByInput>` | No       | Lets you order the returned list by any property.                                                                                                                                                         |
| `cursor`   | `UserWhereUniqueInput`                                       | No       | Specifies the position for the list (the value typically specifies an `id` or another unique value).                                                                                                      |
| `skip`     | `number`                                                     | No       | Specifies how many of the returned objects in the list should be skipped.                                                                                                                                 |
| `take`     | `number`                                                     | No       | Specifies how many objects should be returned in the list (as seen from the _beginning_ (positive value) or _end_ (negative value) **either** of the list **or** from the `cursor` position if mentioned) |
| `distinct` | `Enumerable<UserDistinctFieldEnum>`                          | No       | Lets you filter out duplicate rows by a specific field - for example, return only distinct `Post` titles.                                                                                                 |
| `_count`   | `true`                                                       | No       | Returns a count of matching records or non-`null` fields.                                                                                                                                                 |
| `_avg`     | `UserAvgAggregateInputType`                                  | No       | Returns an average of all values of the specified field.                                                                                                                                                  |
| `_sum`     | `UserSumAggregateInputType`                                  | No       | Returns the sume of all values of the specified field.                                                                                                                                                    |
| `_min`     | `UserMinAggregateInputType`                                  | No       | Returns the smallest available value of the specified field.                                                                                                                                              |
| `_max`     | `UserMaxAggregateInputType`                                  | No       | Returns the largest available value of the specified field.                                                                                                                                               |

#### 参考

`aggregate` 接受以下输入类型:

```ts file=index.d.ts
export type UserAggregateArgs = {
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
  _count?: true | UserCountAggregateInputType
  _avg?: UserAvgAggregateInputType
  _sum?: UserSumAggregateInputType
  _min?: UserMinAggregateInputType
  _max?: UserMaxAggregateInputType
}
```

#### 例子

##### Return `_min`, `_max`, and `_count` of `profileViews` of all `User` records

<CodeWithResult>
<cmd>

```ts
const minMaxAge = await prisma.user.aggregate({
  _count: {
    _all: true,
  },
  _max: {
    profileViews: true,
  },
  _min: {
    profileViews: true,
  },
})
```

</cmd>
<cmdResult>

```js
{
  _count: { _all: 29 },
  _max: { profileViews: 90 },
  _min: { profileViews: 0 }
}
```

</cmdResult>
</CodeWithResult>

##### Return `_sum` of all `profileViews` for all `User` records

<CodeWithResult>
<cmd>

```ts
const setValue = await prisma.user.aggregate({
  _sum: {
    profileViews: true,
  },
})
```

</cmd>
<cmdResult>

```js
{
  "_sum": {
    "profileViews": 9493
  }
}
```

</cmdResult>
</CodeWithResult>

### <inlinecode>groupBy</inlinecode>

See also: [Aggregation, grouping, and summarizing](../../../concepts/components/prisma-client/aggregation-grouping-summarizing#group-by) <span class="concept"></span>

#### 选项

| Name      | Type                                                         | Required | Description                                                                                                                                                                                               |
| --------- | ------------------------------------------------------------ | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`   | `UserWhereInput`                                             | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                                                                                                                      |
| `orderBy` | `XOR<Enumerable<UserOrderByInput>,`<br />`UserOrderByInput>` | No       | Lets you order the returned list by any property that is also present in `by`.                                                                                                                            |
| `by`      | `Array<UserScalarFieldEnum>`                                 | No       | Specifies the field or combination of fields to group records by.                                                                                                                                         |
| `having`  | `UserScalarWhereWithAggregatesInput`                         | No       | Allows you to filter groups by an aggregate value - for example, only return groups _having_ an average age less than 50.                                                                                 |
| `skip`    | `number`                                                     | No       | Specifies how many of the returned objects in the list should be skipped.                                                                                                                                 |
| `take`    | `number`                                                     | No       | Specifies how many objects should be returned in the list (as seen from the _beginning_ (positive value) or _end_ (negative value) **either** of the list **or** from the `cursor` position if mentioned) |
| `_count`  | `true`                                                       | No       | Returns a count of matching records or non-`null` fields.                                                                                                                                                 |
| `_avg`    | `UserAvgAggregateInputType`                                  | No       | Returns an average of all values of the specified field.                                                                                                                                                  |
| `_sum`    | `UserSumAggregateInputType`                                  | No       | Returns the sume of all values of the specified field.                                                                                                                                                    |
| `_min`    | `UserMinAggregateInputType`                                  | No       | Returns the smallest available value of the specified field.                                                                                                                                              |
| `_max`    | `UserMaxAggregateInputType`                                  | No       | Returns the largest available value of the specified field.                                                                                                                                               |

#### 参考

`groupBy` 接受以下输入类型:

```ts file=index.d.ts
export type UserGroupByArgs = {
  where?: UserWhereInput
  orderBy?: Enumerable<UserOrderByInput>
  by: Array<UserScalarFieldEnum>
  having?: UserScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: true | UserCountAggregateInputType
  _avg?: UserAvgAggregateInputType
  _sum?: UserSumAggregateInputType
  _min?: UserMinAggregateInputType
  _max?: UserMaxAggregateInputType
}
```

#### 例子

##### Group by `country`/`city` where the average `profileViews` is greater than `200`, and return the `_sum` of `profileViews` for each group

The query also returns a count of `_all` records in each group, and all records with non-`null` `city` field values in each group.

<CodeWithResult expanded="{true}">
<cmd>

```ts
const groupUsers = await prisma.user.groupBy({
  by: ['country', 'city'],
  _count: {
    _all: true,
    city: true,
  },
  _sum: {
    profileViews: true,
  },
  orderBy: {
    country: 'desc',
  },
  having: {
    profileViews: {
      _avg: {
        gt: 200,
      },
    },
  },
})
```

</cmd>
<cmdResult>

```js
;[
  {
    country: 'Denmark',
    city: 'Copenhagen',
    _sum: { profileViews: 490 },
    _count: {
      _all: 70,
      city: 8,
    },
  },
  {
    country: 'Sweden',
    city: 'Stockholm',
    _sum: { profileViews: 500 },
    _count: {
      _all: 50,
      city: 3,
    },
  },
]
```

</cmdResult>
</CodeWithResult>

## Model query options

### <inlinecode>select</inlinecode>

`select` defines which fields are included in the object that Prisma Client returns. See: [Select fields and include relations](../../../concepts/components/prisma-client/select-fields) <span class="concept"></span>.

#### Remarks

- You cannot combine `select` and `include` on the same level.
- In [2.20.0](https://github.com/prisma/prisma/releases/2.20.0) and later, you can [select a `_count` of relations](#select-a-_count-of-relations).

#### 参考

```ts file=index.d.ts
export type UserSelect = {
  id?: boolean
  name?: boolean
  email?: boolean
  profileViews?: boolean
  role?: boolean
  coinflips?: boolean
  posts?: boolean | PostFindManyArgs
  _count?: boolean | UserCountOutputTypeArgs
}
```

#### 例子

##### Select the `name` and `profileViews` fields of a single `User` record

<CodeWithResult>
<cmd>

```ts
const result = await prisma.user.findUnique({
  where: { id: 1 },
  select: {
    name: true,
    profileViews: true,
  },
})
```

</cmd>
<cmdResult>

```js
{
  name: "Alice",
  profileViews: 0
}
```

</cmdResult>
</CodeWithResult>

##### Select the `name` and `profileViews` fields of a multiple `User` records

<CodeWithResult>
<cmd>

```ts
const result = await prisma.user.findMany({
  select: {
    email: true,
    role: true,
  },
})
```

</cmd>
<cmdResult>

```js
;[
  {
    email: 'alice@prisma.io',
    role: 'ADMIN',
  },
  {
    email: 'bob@prisma.io',
    role: 'USER',
  },
]
```

</cmdResult>
</CodeWithResult>

##### Select a `_count` of relations

<CodeWithResult>
<cmd>

```ts
const usersWithCount = await prisma.user.findMany({
  select: {
    _count: {
      select: { posts: true },
    },
  },
})
```

</cmd>
<cmdResult>

```js
{
  _count: {
    posts: 3
  }
}
```

</cmdResult>
</CodeWithResult>

##### Select the 'id' and 'title' fields of related `Post` records

<CodeWithResult>
<cmd>

```ts
const result = await prisma.user.findMany({
  select: {
    id: true,
    name: true,
    posts: {
      select: {
        id: true,
        title: true,
      },
    },
  },
})
```

</cmd>
<cmdResult>

```ts
;[
  {
    id: 1,
    name: 'Alice',
    posts: [
      { id: 1, title: 'Hello World' },
      { id: 2, title: 'Bye bye' },
    ],
  },
  {
    id: 2,
    name: 'Bob',
    posts: [],
  },
]
```

</cmdResult>
</CodeWithResult>

##### `include` inside `select`

<CodeWithResult>
<cmd>

```ts
const result = await prisma.user.findMany({
  select: {
    id: true,
    name: true,
    posts: {
      include: {
        author: true,
      },
    },
  },
})
```

</cmd>
<cmdResult>

```js
;[
  {
    id: 1,
    name: 'Alice',
    posts: [
      {
        id: 1,
        title: 'Hello World',
        published: true,
        author: {
          id: 1,
          name: 'Alice',
          email: 'alice@prisma.io',
          role: 'ADMIN',
          coinflips: [true, false],
          profileViews: 0,
        },
      },
      {
        id: 2,
        title: 'Bye bye',
        published: false,
        author: {
          id: 1,
          name: 'Alice',
          email: 'alice@prisma.io',
          role: 'USER',
          coinflips: [],
          profileViews: 0,
        },
      },
    ],
  },
]
```

</cmdResult>
</CodeWithResult>

#### Generated types for `select`

The following examples demonstrate how to use the [`validator`](../../concepts/components/prisma-client/advanced-type-safety/prisma-validator) with `select`:

- `SelectAndInclude`
- `UserSelect`

```ts
// SelectAndInclude
const selectNameIncludeEmail = Prisma.validator<Prisma.SelectAndInclude>()({
  select: {
    name: true,
  },
  include: {
    email: true,
  },
})

// UserSelect
const selectNameEmailNotPosts = Prisma.validator<Prisma.UserSelect>()({
  name: true,
  email: true,
  posts: false,
})
```

### <inlinecode>include</inlinecode>

`include` defines which relations are included in the result that the Prisma Client returns. See: [Select fields and include relations](../../../concepts/components/prisma-client/select-fields) <span class="concept"></span>.

#### Remarks

- In [2.20.0](https://github.com/prisma/prisma/releases/2.20.0)P and later, you can [`include` a `_count` of relations](#include-a-_count-of-relations)

#### 参考

```ts
export type UserInclude = {
  posts?: boolean | PostFindManyArgs
  _count?: boolean | UserCountOutputTypeArgs
}
```

#### 例子

##### Include the `posts` and `profile` relation when loading `User` records

```ts
const users = await prisma.user.findMany({
  include: {
    posts: true, // Returns all fields for all posts
    profile: true, // Returns all Profile fields
  },
})
```

##### Include the `posts` relation on the returned objects when creating a new `User` record with two `Post` records

```ts
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    posts: {
      create: [
        { title: 'This is my first post' },
        { title: 'Here comes a second post' },
      ],
    },
  },
  include: { posts: true }, // Returns all fields for all posts
})
```

#### Generated types for `include`

The following examples demonstrate how to use the [`validator`](../../concepts/components/prisma-client/advanced-type-safety/prisma-validator) with `include`:

- `SelectAndInclude`
- `UserInclude`

```ts
// SelectAndInclude
const selectNameIncludeEmail = Prisma.validator<Prisma.SelectAndInclude>()({
  select: {
    name: true,
  },
  include: {
    email: true,
  },
})

// UserInclude
const includePosts = Prisma.validator<Prisma.UserInclude>()({
  posts: true,
})
```

##### Include a `_count` of relations

<CodeWithResult>
<cmd>

```ts
const usersWithCount = await prisma.user.findMany({
  include: {
    _count: {
      select: { posts: true },
    },
  },
})
```

</cmd>
<cmdResult>

```js
{ id: 1, name: "Bob", email: "bob@prisma.io", _count: { posts: 3 } },
{ id: 2,  name: "Enya", email: "enya@prisma.io", _count: { posts: 2 } }
```

</cmdResult>
</CodeWithResult>

### <inlinecode>where</inlinecode>

`where` defines one or more [filters](#filter-conditions-and-operators), and can be used to filter on record properties (like a user's email address) or related record properties (like a user's top 10 most recent post titles).

#### 参考

For queries like `findMany` and `updateMany` that return multiple records, `where` 接受以下输入类型:

```ts file=index.d.ts
export type UserWhereInput = {
  AND?: Enumerable<UserWhereInput>
  OR?: Enumerable<UserWhereInput>
  NOT?: Enumerable<UserWhereInput>
  id?: IntFilter | number
  name?: StringNullableFilter | string | null
  email?: StringFilter | string
  profileViews?: IntFilter | number
  role?: EnumRoleFilter | Role
  coinflips?: BoolNullableListFilter
  posts?: PostListRelationFilter
}
```

> `findFirst` is a `findMany` query with a `take: 1`, and also accepts `UserWhereInput`.

For queries like `findUnique`, which returns a single record by ID or unique identifier, `where` 接受以下输入类型:

```ts file=index.d.ts
export type UserWhereUniqueInput = {
  id?: number
  email?: string
}
```

#### 例子

```ts
const results = await prisma.user.findMany({
  where: {
    email: {
      endsWith: 'prisma.io',
    },
  },
})
```

#### Generated types for `where`

The following examples demonstrate how to use the [`validator`](../../concepts/components/prisma-client/advanced-type-safety/prisma-validator) with `where`:

- `UserWhereInput`

```ts
// UserWhereInput
const whereNameIs = Prisma.validator<Prisma.UserWhereInput>()({
  name: 'Rich',
})

// It can be combined with conditional operators too
const whereNameIs = Prisma.validator<Prisma.UserWhereInput>()({
  name: 'Rich',
  AND: [
    {
      email: {
        contains: 'rich@boop.com',
      },
    },
  ],
})
```

- `UserWhereUniqueInput` This type works by exposing any unique fields on the model. A field assigned `@id` is considered unique,
  as is one assigned `@unique`.

```ts
// UserWhereUniqueInput
const whereEmailIsUnique = Prisma.validator<Prisma.UserWhereUniqueInput>()({
  email: 'rich@boop.com',
})
```

- `PostScalarWhereInput`

```ts
const whereScalarTitleIs = Prisma.validator<Prisma.PostScalarWhereInput>()({
  title: 'boop',
})
```

- `PostUpdateWithWhereUniqueWithoutAuthorInput` - This type accepts a unique `where` field (an `@id` or another assigned `@unique`)
  and updates any field on the `Post` model except the `Author`. The `Author` is the scalar field on the `Post` model.

```ts
const updatePostByIdWithoutAuthor =
  Prisma.validator<Prisma.PostUpdateWithWhereUniqueWithoutAuthorInput>()({
    where: {
      id: 1,
    },
    data: {
      content: 'This is some updated content',
      published: true,
      title: 'This is a new title',
    },
  })
```

- `PostUpsertWithWhereUniqueWithoutAuthorInput` - This type will update the `Post` records title field where the id matches, if it doesn't exist it will create it instead.

```ts
const updatePostTitleOrCreateIfNotExist =
  Prisma.validator<Prisma.PostUpsertWithWhereUniqueWithoutAuthorInput>()({
    where: {
      id: 1,
    },
    update: {
      title: 'This is a new title',
    },
    create: {
      id: 1,
      title: 'If the title doesnt exist, then create one with this text',
    },
  })
```

- `PostUpdateManyWithWhereWithoutAuthorInput` - This type will update all `Post` records where published is set to false.

```ts
const publishAllPosts =
  Prisma.validator<Prisma.PostUpdateManyWithWhereWithoutAuthorInput>()({
    where: {
      published: {
        equals: false,
      },
    },
    data: {
      published: true,
    },
  })
```

### <inlinecode>orderBy</inlinecode>

Sorts a list of records. See also: [Sorting](../../../concepts/components/prisma-client/filtering-and-sorting) <span class="concept"></span>

#### Remarks

- In [2.16.0](https://github.com/prisma/prisma/releases/2.16.0) and later, you can [order by relation fields](#sort-post-by-the-related-user-records-name) (Preview) - for example, order posts by the author's name

#### Inputs

| Name   | Description                  |
| ------ | ---------------------------- |
| `asc`  | Sort ascending (A &rarr; Z)  |
| `desc` | Sort descending (Z &rarr; A) |

#### 参考

`orderBy` 接受以下输入类型:

```ts file=index.d.ts
export type UserOrderByInput = {
  id?: SortOrder
  name?: SortOrder
  email?: SortOrder
  profileViews?: SortOrder
  role?: SortOrder
  coinflips?: SortOrder
  posts?: PostOrderByAggregateInput
  profile?: ExtendedProfileOrderByWithRelationInput
}
```

Related types:

```ts
export type PostOrderByAggregateInput = {
  count: SortOrder
}

export type ExtendedProfileOrderByWithRelationInput = {
  id?: SortOrder
  biograpy?: SortOrder
  userId?: SortOrder
  user?: UserOrderByWithRelationInput
}

export declare const SortOrder: {
  asc: 'asc'
  desc: 'desc'
}
```

#### 例子

##### Sort `User` by `email` field

The following example returns all `User` records sorted by `email` ascending:

```ts
const users = await prisma.user.findMany({
  orderBy: {
    email: 'asc',
  },
})
```

The following example returns all `User` records sorted by `email` descending:

```ts
const users = await prisma.user.findMany({
  orderBy: {
    email: 'desc',
  },
})
```

#### Sort `Post` by the related `User` record's `name`

Sorting by relation fields is a Preview feature. To enable this feature, add `orderByRelation` to `previewFeatures` in your schema:

```prisma highlight=3;normal
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["orderByRelation"]
}
```

The following query orders posts by user name:

```ts
const posts = await prisma.post.findMany({
  orderBy: {
    author: {
      name: 'asc',
    },
  },
})
```

#### Sort `User` by the `posts` count

Sorting by relation count is a Preview feature. To enable this feature, add `orderByRelation` to `previewFeatures` in your schema:

```prisma highlight=3;normal
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["orderByRelation"]
}
```

The following query orders users by post count:

```ts
const getActiveusers = await prisma.user.findMany({
  orderBy: {
    posts: {
      count: 'desc',
    },
  },
})
```

##### Sort `User` by multiple fields - `email` _and_ `role`

The following example sorts users by two fields - first `email`, then `role`:

<CodeWithResult>

<cmd>

```ts
const users = await prisma.user.findMany({
  select: {
    email: true,
    role: true,
  },
  orderBy: [
    {
      email: 'desc',
    },
    {
      role: 'desc',
    },
  ],
})
```

</cmd>

<cmdResult>

```json
[
  {
    "email": "yuki@prisma.io",
    "role": "USER"
  },
  {
    "email": "nora@prisma.io",
    "role": "USER"
  },
  {
    "email": "mary@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "elsa@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "eloise@prisma.io",
    "role": "USER"
  },
  {
    "email": "coco@prisma.io",
    "role": "ADMIN"
  },
  {
    "email": "anna@prisma.io",
    "role": "USER"
  },
  {
    "email": "alice@prisma.io",
    "role": "USER"
  }
]
```

</cmdResult>

</CodeWithResult>

The order of sorting parameters matters - the following query sorts by `role`, then `email`. Not the difference in the results:

<CodeWithResult>

<cmd>

```ts
const users = await prisma.user.findMany({
  select: {
    email: true,
    role: true,
  },
  orderBy: [
    {
      role: 'desc',
    },
    {
      email: 'desc',
    },
  ],
})
```

</cmd>

<cmdResult>

```json
[
  {
    "email": "mary@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "elsa@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "yuki@prisma.io",
    "role": "USER"
  },
  {
    "email": "nora@prisma.io",
    "role": "USER"
  },
  {
    "email": "eloise@prisma.io",
    "role": "USER"
  },
  {
    "email": "anna@prisma.io",
    "role": "USER"
  },
  {
    "email": "alice@prisma.io",
    "role": "USER"
  },
  {
    "email": "coco@prisma.io",
    "role": "ADMIN"
  }
]
```

</cmdResult>

</CodeWithResult>

##### Sort `User` by `email`, select `name` and `email`

The following example returns all the `name` and `email` fields of all `User` records, sorted by `email`:

<CodeWithResult>

<cmd>

```ts
const users3 = await prisma.user.findMany({
  orderBy: {
    email: 'asc',
  },
  select: {
    name: true,
    email: true,
  },
})
```

</cmd>

<cmdResult>

```js
;[
  {
    name: 'Alice',
    email: 'alice@prisma.io',
  },
  {
    name: 'Ariadne',
    email: 'ariadne@prisma.io',
  },
  {
    name: 'Bob',
    email: 'bob@prisma.io',
  },
]
```

</cmdResult>

</CodeWithResult>

##### Sort `User` records by `email` and sort nested `Post` records by `title`

The following example:

- Returns all `User` records sorted by `email`
- For each `User` record, returns the `title` field of all nested `Post` records sorted by `title`

<CodeWithResult>

<cmd>

```ts
const usersWithPosts = await prisma.user.findMany({
  orderBy: {
    email: 'asc',
  },
  include: {
    posts: {
      select: {
        title: true,
      },
      orderBy: {
        title: 'asc',
      },
    },
  },
})
```

</cmd>

<cmdResult>

```json
[
  {
    "id": 2,
    "email": "alice@prisma.io",
    "name": "Alice",
    "posts": [
      {
        "title": "Watch the talks from Prisma Day 2019"
      }
    ]
  },
  {
    "id": 3,
    "email": "ariadne@prisma.io",
    "name": "Ariadne",
    "posts": [
      {
        "title": "How to connect to a SQLite database"
      },
      {
        "title": "My first day at Prisma"
      }
    ]
  },
  {
    "id": 1,
    "email": "bob@prisma.io",
    "name": "Bob",
    "posts": [
      {
        "title": "Follow Prisma on Twitter"
      },
      {
        "title": "Subscribe to GraphQL Weekly for community news "
      }
    ]
  }
]
```

</cmdResult>

</CodeWithResult>

##### Sort one user's nested list of `Post` records

The following example retrieves a single `User` record by ID, as well as a list of nested `Post` records sorted by `title`:

<CodeWithResult>

<cmd>

```ts
const userWithPosts = await prisma.user.findUnique({
  where: {
    id: 1,
  },
  include: {
    posts: {
      orderBy: {
        title: 'desc',
      },
      select: {
        title: true,
        published: true,
      },
    },
  },
})
```

</cmd>

<cmdResult>

```json
{
  "email": "sarah@prisma.io",
  "id": 1,
  "name": "Sarah",
  "extendedProfile": null,
  "role": "USER",
  "posts": [
    {
      "title": "Prisma Day 2020",
      "published": false
    },
    {
      "title": "My first post",
      "published": false
    },
    {
      "title": "All about databases",
      "published": true
    }
  ]
}
```

</cmdResult>

</CodeWithResult>

##### Sort by `enum`

The following sorts all `User` records by `role` (an `enum`):

<CodeWithResult>

<cmd>

```ts
const sort = await prisma.user.findMany({
  orderBy: {
    role: 'desc',
  },
  select: {
    email: true,
    role: true,
  },
})
```

</cmd>

<cmdResult>

```json
[
  {
    "email": "emma@prisma.io",

    "role": "USER"
  },
  {
    "email": "suma@prisma.io",
    "role": "ADMIN"
  },
  {
    "email": "kwame@prisma.io",
    "role": "ADMIN"
  },
  {
    "email": "pearl@prisma.io",
    "role": "ADMIN"
  }
]
```

</cmdResult>

</CodeWithResult>

#### Generated types for `orderBy`

The following examples demonstrate how to use the [`validator`](../../concepts/components/prisma-client/advanced-type-safety/prisma-validator) with `orderBy`:

- `UserOrderByInput`
  ```ts
  const orderEmailsByDescending = Prisma.validator<Prisma.UserOrderByInput>()({
    email: 'desc',
  })
  ```

### <inlinecode>distinct</inlinecode>

See also: [Aggregation, grouping, and summarizing](../../../concepts/components/prisma-client/aggregation-grouping-summarizing#select-distinct) <span class="concept"></span>

#### 参考

```ts file=index.d.ts
distinct?: Enumerable<UserDistinctFieldEnum>
```

```ts
export declare const UserDistinctFieldEnum: {
  id: 'id'
  name: 'name'
  email: 'email'
  profileViews: 'profileViews'
  role: 'role'
  coinflips: 'coinflips'
}
```

#### 例子

##### Select distinct on a single field

The following example returns all distinct `city` fields, and selects only the `city` and `country` fields:

<CodeWithResult  expanded={true}>

<cmd>

```ts
const distinctCities = await prisma.user.findMany({
  select: {
    city: true,
    country: true,
  },
  distinct: ['city'],
})
```

</cmd>

<cmdResult>

```js no-lines
;[
  { city: 'Paris', country: 'France' },
  { city: 'Lyon', country: 'France' },
]
```

</cmdResult>

</CodeWithResult>

##### Select distinct on multiple fields

The following example returns all distinct `city` _and_ `country` field combinations, and selects only the `city` and `country` fields:

<CodeWithResult expanded={true}>

<cmd>

```ts
const distinctCitiesAndCountries = await prisma.user.findMany({
  select: {
    city: true,
    country: true,
  },
  distinct: ['city', 'country'],
})
```

</cmd>

<cmdResult>

```js no-lines
;[
  { city: 'Paris', country: 'France' },
  { city: 'Paris', country: 'Denmark' },
  { city: 'Lyon', country: 'France' },
]
```

</cmdResult>

</CodeWithResult>

Note that there is now a "Paris, Denmark" in addition to "Paris, France":

##### Select distinct in combination with a filter

The following example returns all distinct `city` _and_ `country` field combinations where the user's email contains `"prisma.io"`, and selects only the `city` and `country` fields:

<CodeWithResult>

<cmd>

```ts
const distinctCitiesAndCountries = await prisma.user.findMany({
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
  select: {
    city: true,
    country: true,
  },
  distinct: ['city', 'country'],
})
```

</cmd>

<cmdResult>

```js
;[
  { city: 'Paris', country: 'Denmark' },
  { city: 'Lyon', country: 'France' },
]
```

</cmdResult>

</CodeWithResult>

## Nested queries

### <inlinecode>create</inlinecode>

A nested `create` query adds a new related record or set of records to a parent record. See: [Working with relations](../../../concepts/components/prisma-client/relation-queries) <span class="concept"></span>.

#### Remarks

- `create` is available as a nested query when you `create` (`prisma.user.create(...)`) a new parent record or `update` (`prisma.user.update(...)`) an existing parent record.

> You can use a nested `create` _or_ a nested `createMany` to create multiple related records - [each technique pros and cons](../../concepts/components/prisma-client/relation-queries/#create-a-single-record-and-multiple-related-records) <span class="concept"></span>.

#### 例子

##### Create a new `User` record with a new `Profile` record

```ts highlight=5;normal
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    profile: {
      create: { bio: 'Hello World' },
    },
  },
})
```

##### Create a new `Profile` record with a new `User` record

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    user: {
|     create: { email: 'alice@prisma.io' },
    },
  },
})
```

##### Create a new `User` record with a new `Post` record

```ts highlight=5;normal
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    posts: {
      create: { title: 'Hello World' },
    },
  },
})
```

##### Create a new `User` record with two new `Post` records

Because it's a one-to-many relation, you can also create several `Post` records at once by passing an array to `create`:

```ts highlight=5;normal
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    posts: {
      create: [
        {
          title: 'This is my first post',
        },
        {
          title: 'Here comes a second post',
        },
      ],
    },
  },
})
```

You can also use a nested [`createMany`](#createmany-1) to achieve the same result.

##### Update an existing `User` record by creating a new `Profile` record

```ts highlight=5;normal;
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      create: { bio: 'Hello World' },
    },
  },
})
```

##### Update an existing `User` record by creating a new `Post` record

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
|      create: { title: 'Hello World' },
    },
  },
})
```

### <inlinecode>createMany</inlinecode>

A nested `createMany` query adds a new set of records to a parent record. See: [Working with relations](../../../concepts/components/prisma-client/relation-queries) <span class="concept"></span>.

#### Remarks

- `createMany` is available as a nested query when you `create` (`prisma.user.create(...)`) a new parent record or `update` (`prisma.user.update(...)`) an existing parent record.
- Available in the context of a has-many relation - for example, you can `prisma.user.create(...)` a user and use a nested `createMany` to create multiple posts (posts have one user).
- **Not** available in the context of a many-to-many relation - for example, you **cannot** you can `prisma.post.create(...)` a post and use a nested `createMany` to create categories (many posts have many categories).
- Does not support nesting additional relations - you cannot nest an additional `create` or `createMany`.
- Allows setting foreign keys directly - for example, setting the `categoryId` on a post.

> You can use a nested `create` _or_ a nested `createMany` to create multiple related records - [each technique pros and cons](../../concepts/components/prisma-client/relation-queries/#create-a-single-record-and-multiple-related-records) <span class="concept"></span>.

#### 例子

##### Update a `User` and multiple new related `Post` records

```ts
const user = await prisma.user.update({
  where: {
    id: 9,
  },
  data: {
    name: 'Elliott',
    posts: {
      createMany: {
        data: [{ title: 'My first post' }, { title: 'My second post' }],
      },
    },
  },
})
```

### <inlinecode>set</inlinecode>

`set` overwrites the value of a relation - for example, replacing a list of `Post` records with a different list. See: [Working with relations](../../../concepts/components/prisma-client/relation-queries) <span class="concept"></span>

#### 例子

##### Update an existing `User` record by disconnecting any previous `Post` records and connecting two other existing ones

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      set: [{ id: 32 }, { id: 42 }],
    },
  },
})
```

### <inlinecode>connect</inlinecode>

<AlgoliaTerm name="apiReference" value="connect" />

A nested `connect` query connects a record to an existing related record by specifying an ID or unique identifier. See: [Working with relations](../../../concepts/components/prisma-client/relation-queries) <span class="concept"></span>

#### Remarks

- `connect` is available as a nested query when you create a new parent record or update an existing parent record.
- If the related record does not exist, Prisma Client throws an exception:

  ```
  The required connected records were not found. Expected 1 records to be connected, found 0.
  ```

#### 例子

##### Create a new `Profile` record and connect it to an existing `User` record via unique field

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    user: {
      connect: { email: 'alice@prisma.io' },
    },
  },
})
```

##### Create a new `Profile` record and connect it to an existing `User` record via an ID field

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    user: {
      connect: { id: 42 }, // sets userId of Profile record
    },
  },
})
```

In [2.11.0](https://github.com/prisma/prisma/releases/2.11.0) and later, you can set the foreign key directly:

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    userId: 42,
  },
})
```

##### Create a new `Post` record and connect it to an existing `User` record

```ts
const user = await prisma.post.create({
  data: {
    title: 'Hello World',
    author: {
      connect: { email: 'alice@prisma.io' },
    },
  },
})
```

##### Update an existing `User` record by connecting it to an existing `Profile` record

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      connect: { id: 24 },
    },
  },
})
```

##### Update an existing `User` record by connecting it to two existing `Post` records

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      connect: [{ id: 24 }, { id: 42 }],
    },
  },
})
```

### <inlinecode>connectOrCreate</inlinecode>

<AlgoliaTerm name="apiReference" value="connectOrCreate" />

`connectOrCreate` _either_ connects a record to an existing related record by ID or unique identifier _or_ creates a new related record if the record does not exist. See: [Working with relations](../../../concepts/components/prisma-client/relation-queries) <span class="concept"></span>

#### Remarks

<!-- prettier-ignore-start -->

- Multiple `connectOrCreate` queries that run _as concurrent transactions_ can result in a **race condition**. Consider the following example, where two queries attempt to `connectOrCreate` a blog post tag named `computing` at the same time (tag names must be unique):

  <TabbedContent tabs={[<FileWithIcon text="Query A" icon="code"/>, <FileWithIcon text="Query B" icon="code"/>]}>
  <tab>

  ```ts
  const createPost = await prisma.post.create({
    data: {
      title: 'How to create a compiler',
      content: '...',
      author: {
        connect: {
          id: 9,
        },
      },
      tags: {
        connectOrCreate: {
          create: {
            name: 'computing',
          },
          where: {
            name: 'computing',
          },
        },
      },
    },
  })
  ```

  </tab>
    <tab>

  ```ts
  const createPost = await prisma.post.create({
    data: {
      title: 'How to handle schema drift in production',
      content: '...',
      author: {
        connect: {
          id: 15,
        },
      },
      tags: {
        connectOrCreate: {
          create: {
            name: 'computing',
          },
          where: {
            name: 'computing',
          },
        },
      },
    },
  })
  ```

  </tab>
  </TabbedContent>

  If query A and query B overlap in the following way, query A results in an exception:

  | Query A (Fail ❌)                                                | Query B (Success ✅)                                             |
  | :--------------------------------------------------------------- | :--------------------------------------------------------------- |
  | Query hits server, starts transaction A                          | Query hits server, starts transaction B                          |
  |                                                                  | Find record where `tagName` equals `computing`, record not found |
  | Find record where `tagName` equals `computing`, record not found |                                                                  |
  |                                                                  | Create record where `tagName` equals `computing` and connect     |
  | Create record where `tagName` equals `computing`                 |                                                                  |
  | Unique violation, record already created by transaction B        |                                                                  |

  To work around this scenario, we recommend catching the unique violation exception (`PrismaClientKnownRequestError`, error `P2002`) and retrying failed queries.

<!-- prettier-ignore-end -->

#### 例子

##### Create a new `Profile` record, then connect it to an existing `User` record _or_ create a new `User`

The following example:

1. Creates a `Profile`
2. Attempts to connect the profile to a `User` where the email address is `alice@prisma.io`
3. Creates a new user if a user if a matching user does not exist

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'The coolest Alice on the planet',
    user: {
      connectOrCreate: {
        where:  { email: 'alice@prisma.io' },
        create: { email: 'alice@prisma.io'}
    },
  },
})
```

##### Create a new `Post` record and connect it to an existing `User` record, _or_ create a new `User`

```ts
const user = await prisma.post.create({
  data: {
    title: 'Hello World',
    author: {
      connectOrCreate: {
        where: { email: 'alice@prisma.io' },
        create: { email: 'alice@prisma.io' },
      },
    },
  },
})
```

##### Update an existing `User` record by connecting it to an existing `Profile` record, _or_ creating a new `Profile` record

The following example:

2. Attempts to connect the user to a `Profile` with an `id` of `20`
3. Creates a new profile if a matching profile does not exist

```ts
const updateUser = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      connectOrCreate: {
        where: { id: 20 },
        create: {
          bio: 'The coolest Alice in town',
        },
      },
    },
  },
})
```

##### Update an existing `User` record by connect it to two existing `Post` records, or creating two new `Post` records

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      connectOrCreate: [
        {
          where: { id: 32 },
          create: { title: 'This is my first post' },
        },
        {
          where: { id: 19 },
          create: { title: 'This is my second post' },
        },
      ],
    },
  },
})
```

### <inlinecode>disconnect</inlinecode>

<AlgoliaTerm name="apiReference" value="disconnect" />

A nested `disconnect` query breaks the connection between a parent record and a related record, but does not delete either record. See: [Working with relations](../../../concepts/components/prisma-client/relation-queries) <span class="concept"></span>

#### Remarks

- `disconnect` is only available if the relation is optional.
- If the relationship you are attempting to disconnect does not exist:

  - ([In 2.21.0 and later](https://github.com/prisma/prisma/releases/tag/2.21.0)), the operation does nothing
  - (Before [2.21.0](https://github.com/prisma/prisma/releases/tag/2.21.0)) Prisma Client throws an exception if the provided ID or unique identifier is not connected:

    ```
    The records for relation `PostToUser` between the `User` and `Post` models are not connected.
    ```

#### 例子

##### Update an existing `User` record by disconnecting the `Profile` record it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'bob  @prisma.io' },
  data: {
    profile: {
      disconnect: true,
    },
  },
})
```

##### Update an existing `User` record by disconnecting two `Post` records it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      disconnect: [{ id: 44 }, { id: 46 }],
    },
  },
})
```

### <inlinecode>update</inlinecode>

<AlgoliaTerm name="apiReference" value="update" />

A nested `update` query updates one or more related records where the parent record's ID is `n`. See: [Working with relations](../../../concepts/components/prisma-client/relation-queries#update-a-specific-related-record) <span class="concept"></span>

#### Remarks

- Nested `update` queries are only available in the context of a top-level `update` query (for example, `prisma.user.update(...)`).
- If the parent record does not exist, Prisma Client throws an exception:

  ```
  AssertionError("Expected a valid parent ID to be present for nested update to-one case.")
  ```

- If the related record that you want to update does not exist, Prisma Client throws an exception:

  ```
  AssertionError("Expected a valid parent ID to be present for nested update to-one case.")
  ```

#### 例子

##### Update an existing `User` record by updating the `Profile` record it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      update: { bio: 'Hello World' },
    },
  },
})
```

##### Update an existing `User` record by updating two `Post` records it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      update: [
        {
          data: { published: true },
          where: { id: 32 },
        },
        {
          data: { published: true },
          where: { id: 23 },
        },
      ],
    },
  },
})
```

### <inlinecode>upsert</inlinecode>

<AlgoliaTerm name="apiReference" value="upsert" />

A nested `upsert` query updates a related record if it exists, or creates a new related record.

#### 例子

##### Update an existing `User` record by updating the `Profile` record it's connected to or creating a new one (_upsert_)

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      upsert: {
        create: { bio: 'Hello World' },
        update: { bio: 'Hello World' },
      },
    },
  },
})
```

##### Update an existing `User` record by updating two `Post` record it's connected to or creating new ones (_upsert_)

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      upsert: [
        {
          create: { title: 'This is my first post' },
          update: { title: 'This is my first post' },
          where: { id: 32 },
        },
        {
          create: { title: 'This is mt second post' },
          update: { title: 'This is mt second post' },
          where: { id: 23 },
        },
      ],
    },
  },
})
```

### <inlinecode>delete</inlinecode>

<AlgoliaTerm name="apiReference" value="delete" />

A nested `delete` query deletes a related record. The parent record is not deleted.

#### Remarks

- `delete` is only available if the relation is optional.

#### 例子

##### Update an existing `User` record by deleting the `Profile` record it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      delete: true,
    },
  },
})
```

##### Update an existing `User` record by deleting two `Post` records it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      delete: [{ id: 34 }, { id: 36 }],
    },
  },
})
```

### <inlinecode>updateMany</inlinecode>

<AlgoliaTerm name="apiReference" value="updateMany" />

A nested `updateMany` updates a list of related records and supports filtering - for example, you can update a user's unpublished posts.

#### 例子

##### Update all unpublished posts belonging to a specific user

```ts
const result = await prisma.user.update({
  where: {
    id: 2,
  },
  data: {
    posts: {
      updateMany: {
        where: {
          published: false,
        },
        data: {
          likes: 0,
        },
      },
    },
  },
})
```

### <inlinecode>deleteMany</inlinecode>

<AlgoliaTerm name="apiReference" value="deleteMany" />

A nested `deleteMany` deletes related records and supports filtering. For example, you can delete a user's posts while updating other properties of that user.

#### 例子

##### Delete all posts belonging to a specific user as part of an update

```ts
const result = await prisma.user.update({
  where: {
    id: 2,
  },
  data: {
    name: 'Updated name',
    posts: {
      deleteMany: {},
    },
  },
})
```

## Filter conditions and operators

### <inlinecode>equals</inlinecode>

Value equals `n`.

#### 例子

##### Return all users where `name` equals `"Eleanor"`

```ts
const result = await prisma.user.findMany({
  where: {
    name: {
      equals: 'Eleanor',
    },
  },
})
```

You can also exclude the `equals`:

```ts
const result = await prisma.user.findMany({
  where: {
    name: 'Eleanor',
  },
})
```

### <inlinecode>not</inlinecode>

Value does not equal `n`.

#### 例子

##### Return all users where `name` does **not** equal `"Eleanor"`

```ts
const result = await prisma.user.findMany({
  where: {
    name: {
      not: 'Eleanor',
    },
  },
})
```

### <inlinecode>in</inlinecode>

Value `n` exists in list.

#### Remarks

- `null` values are not returned. For example, if you combine `in` and `NOT` to return user whose name is _not_ in the list, users with `null` value names are not returned.

#### 例子

##### Get `User` records where the `id` can be found in the following list: `[22, 91, 14, 2, 5]`

```ts
const getUser = await prisma.user.findMany({
  where: {
    id: { in: [22, 91, 14, 2, 5] },
  },
})
```

##### Get `User` records where the `name` can be found in the following list: `['Saqui', 'Clementine', 'Bob']`

```ts
const getUser = await prisma.user.findMany({
  where: {
    name: { in: ['Saqui', 'Clementine', 'Bob'] },
  },
})
```

##### Get `User` records where `name` is **not** present in the list

The following example combines `in` and [`NOT`](#not). You can also use [`notIn`](#notin).

```ts
const getUser = await prisma.user.findMany({
  where: {
    NOT: {
      name: { in: ['Saqui', 'Clementine', 'Bob'] },
    },
  },
})
```

##### Get a `User` record where at least one `Post` has at least one specified `Category`

```ts
const getUser = await prisma.user.findMany({
  where: {
    // Find users where..
    posts: {
      some: {
        // ..at least one (some) posts..
        categories: {
          some: {
            // .. have at least one category ..
            name: {
              in: ['Food', 'Introductions'], // .. with a name that matches one of the following.
            },
          },
        },
      },
    },
  },
})
```

### <inlinecode>notIn</inlinecode>

Value `n` does not exist in list.

#### Remarks

- `null` values are not returned.

#### 例子

##### Get `User` records where the `id` can **not** be found in the following list: `[22, 91, 14, 2, 5]`

```ts
const getUser = await prisma.user.findMany({
  where: {
    id: { notIn: [22, 91, 14, 2, 5] },
  },
})
```

### <inlinecode>lt</inlinecode>

Value `n` is less than `x`.

#### 例子

##### Get all `Post` records where `likes` is less than `9`

```ts
const getPosts = await prisma.post.findMany({
  where: {
    likes: {
      lt: 9,
    },
  },
})
```

### <inlinecode>lte</inlinecode>

Value `n` is less than _or_ equal to `x`.

#### 例子

##### Get all `Post` records where `likes` is less or equal to `9`

```ts
const getPosts = await prisma.post.findMany({
  where: {
    likes: {
      lte: 9,
    },
  },
})
```

### <inlinecode>gt</inlinecode>

Value `n` is greater than `x`.

#### 例子

##### Get all `Post` records where `likes` is greater than `9`

```ts
const getPosts = await prisma.post.findMany({
  where: {
    likes: {
      gt: 9,
    },
  },
})
```

### <inlinecode>gte</inlinecode>

Value `n` is greater than _or_ equal to `x`.

#### 例子

##### Get all `Post` records where `likes` is greater than or equal to `9`

```ts
const getPosts = await prisma.post.findMany({
  where: {
    likes: {
      gte: 9,
    },
  },
})
```

#### 例子

##### Get all `Post` records where `date_created` is greater than March 19th, 2020

```js
const result = await prisma.post.findMany({
  where: {
    date_created: {
      gte: new Date(
        '2020-03-19T14:21:00+0200'
      ) /* Includes time offset for UTC */,
    },
  },
})
```

### <inlinecode>contains</inlinecode>

Value `n` contains `x`.

#### 例子

##### Count all `Post` records where `content` contains `databases`

```js
const result = await prisma.post.count({
  where: {
    content: {
      contains: 'databases',
    },
  },
})
```

##### Count all `Post` records where `content` **does not** contain `databases`

```js
const result = await prisma.post.count({
  where: {
    NOT: {
      content: {
        contains: 'databases',
      },
    },
  },
})
```

### <inlinecode>mode</inlinecode>

#### Remarks

- Supported by the PostgreSQL and MongoDB connectors only

#### 例子

##### Get all `Post` records where `title` contains `prisma`, in a case insensitive way

```js
const result = await prisma.post.findMany({
  where: {
    title: {
      contains: 'prisma',
      mode: 'insensitive',
    },
  },
})
```

### <inlinecode>startsWith</inlinecode>

#### 例子

##### Get all `Post` records where `title` starts with `Pr` (such as `Prisma`)

```js
const result = await prisma.post.findMany({
  where: {
    title: {
      startsWith: 'Pr',
    },
  },
})
```

### <inlinecode>endsWith</inlinecode>

#### Get all `User` records where `email` ends with `prisma.io`

```js
const result = await prisma.user.findMany({
  where: {
    email: {
      endsWith: 'prisma.io',
    },
  },
})
```

### <inlinecode>AND</inlinecode>

All conditions must return `true`. Alternatively, pass a list of objects into the `where` clause - the [`AND` operator is not required](#get-all-post-records-where-the-content-field-contains-prisma-and-published-is-false-no-and).

#### 例子

##### Get all `Post` records where the `content` field contains `Prisma` and `published` is `false`

```js
const result = await prisma.post.findMany({
  where: {
    AND: [
      {
        content: {
          contains: 'Prisma',
        },
      },
      {
        published: {
          equals: false,
        },
      },
    ],
  },
})
```

##### Get all `Post` records where the `content` field contains `Prisma` and `published` is `false` (no `AND`)

The following format returns the same results as the previous example **without** the `AND` operator:

```js
const result = await prisma.post.findMany({
  where: {
    content: {
      contains: 'Prisma',
    },
    published: {
      equals: false,
    },
  },
})
```

##### Get all `Post` records where the `title` field contains `Prisma` or `databases`, and `published` is `false`

The following example combines `OR` and `AND`:

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    AND: {
      published: false,
    },
  },
})
```

### <inlinecode>OR</inlinecode>

One or more conditions must return `true`.

#### 例子

##### Get all `Post` records where the `title` field contains `Prisma` or `databases`

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
  },
})
```

##### Get all `Post` records where the `title` filed contains `Prisma` or `databases`, but not `SQL`

The following example combines `OR` and `NOT`:

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    NOT: {
      title: {
        contains: 'SQL',
      },
    },
  },
})
```

##### Get all `Post` records where the `title` field contains `Prisma` or `databases`, and `published` is `false`

The following example combines `OR` and `AND`:

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    AND: {
      published: false,
    },
  },
})
```

### <inlinecode>NOT</inlinecode>

All conditions must return `false`.

#### 例子

##### Get all `Post` records where the `title` filed contains `Prisma` or `databases`, but not `SQL`

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    NOT: {
      title: {
        contains: 'SQL',
      },
    },
  },
})
```

##### Get all `Post` records where the `title` field contains `Prisma` or `databases`, but not `SQL`, and the related `User` record' email address does not contain `sarah`

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    NOT: {
      title: {
        contains: 'SQL',
      },
    },
    user: {
      NOT: {
        email: {
          contains: 'sarah',
        },
      },
    },
  },
  include: {
    user: true,
  },
})
```

## Relation filters

### <inlinecode>some</inlinecode>

Returns all records where **one or more** ("some") _related_ records match filtering criteria.

#### Remarks

- You can use `some` without parameters to return all records with at least one relation

#### 参考

```ts file=index.d.ts
export type PostFilter = {
  every?: PostWhereInput | null
|  some?: PostWhereInput | null
  none?: PostWhereInput | null
}
```

#### 例子

##### Get all `User` records where _all_ posts are published and a least one related `Post` mentions `Prisma`

```ts
const result = await prisma.user.findMany({
  where: {
    post: {
      every: {
        published: true
      },
      some: {
        content: {
          contains: "Prisma"
        }
      }
    }
  }
}
```

### <inlinecode>every</inlinecode>

Returns all records where **all** ("every") _related_ records match filtering criteria.

#### 参考

```ts file=index.d.ts
export type PostFilter = {
|  every?: PostWhereInput | null
  some?: PostWhereInput | null
  none?: PostWhereInput | null
}
```

#### 例子

##### Get all `User` records where _all_ posts are published and a least one related `Post` mentions `Prisma`

```ts
const result = await prisma.user.findMany({
  where: {
    post: {
      every: {
        published: true
      },
      some: {
        content: {
          contains: "Prisma"
        }
      }
    }
  }
}
```

### <inlinecode>none</inlinecode>

Returns all records where **zero** _related_ records match filtering criteria.

#### Remarks

- You can use `none` without parameters to [return all records with no relations](#get-all-user-records-with-zero-posts)

#### 参考

```ts file=index.d.ts
export type PostFilter = {
  every?: PostWhereInput | null
  some?: PostWhereInput | null
|  none?: PostWhereInput | null
}
```

#### 例子

##### Get all `User` records with zero posts

```ts
const result = await prisma.user.findMany({
  where: {
    post: {
        none: {} // User has no posts
    }
  }
}
```

##### Get all `User` records with zero published posts

```ts
const result = await prisma.user.findMany({
  where: {
    post: {
        none: {
          published: true
        }
    }
  }
}
```

### <inlinecode>is</inlinecode>

Returns all records where related record matches filtering criteria (for example, user's name `is` Bob).

#### 参考

```ts file=index.d.ts highlight=2;normal
export type UserRelationFilter = {
  is?: UserWhereInput | null
  isNot?: UserWhereInput | null
}
```

#### 例子

##### Get all `Post` records where user's name is `"Bob"`

```ts
const result = await prisma.post.findMany({
  where: {
    user: {
        is: {
          name: "Bob"
        },
    }
  }
}
```

### <inlinecode>isNot</inlinecode>

Returns all records where related record matches filtering criteria (for example, user's name `isNot` Bob).

#### 参考

```ts file=index.d.ts highlight=3;normal
export type UserRelationFilter = {
  is?: UserWhereInput | null
  isNot?: UserWhereInput | null
}
```

#### 例子

##### Get all `Post` records where user's name is NOT `"Bob"`

```ts
const result = await prisma.post.findMany({
  where: {
    user: {
        isNot: {
          name: "Bob"
        },
    }
  }
}
```

## Scalar list methods

### Reference

```ts
export type PostUpdatetagsInput = {
  set?: Enumerable<string>
  push?: string
}
```

### <inlinecode>set</inlinecode>

Use `set` to overwrite the value of a scalar list field.

#### Remarks

- `set` is optional - you can set the value directly:

  ```ts
  tags: ['computers', 'books']
  ```

#### 例子

##### Set the value of `tags` to a list of string values

```ts
const setTags = await prisma.post.update({
  where: {
    id: 9
  },
  data: {
      tags: {
        set: ["computing", "books"]
      }
    }
  })
}
```

##### Set `tags` to a list of values _without_ using the `set` keyword

```ts
const setTags = await prisma.post.update({
  where: {
    id: 9
  },
  data: {
      tags: ["computing", "books"]
    }
  })
}
```

#### Set the value of `tags` to a single string value

```ts
const setTags = await prisma.post.update({
  where: {
    id: 9,
  },
  data: {
    tags: {
      set: 'computing',
    },
  },
})
```

### <inlinecode>push</inlinecode>

`push` is available in version [2.20.0](https://github.com/prisma/prisma/releases/2.20.0) and later. Use `push` to add _one_ value to a scalar list field.

#### Remarks

- Available for PostgreSQL only.
- You cannot push a list of values - only a single value.

#### 例子

##### Add a `computing` item to the `tags` list

```ts
const addTag = await prisma.post.update({
  where: {
    id: 9,
  },
  data: {
    tags: {
      push: 'computing',
    },
  },
})
```

## Scalar list filters

Scalar list filters allow you to filter by the contents of a list / array field.

<Admonition type="warning">

**Note**: Available for the **PostgreSQL** database connector in Prisma [2.15.0](https://github.com/prisma/prisma/releases/tag/2.15.0) and later **only**.

</Admonition>

### Remarks

- Scalar list / array filters [ignore `NULL` values](../../../concepts/components/prisma-client/working-with-fields/working-with-scalar-lists-arrays#null-values-in-arrays) <span class="concept"></span>. Using `isEmpty` or `NOT` does not return records with `NULL` value lists / arrays, and `{ equals: null }` results in an error.

### Reference

```ts file=index.d.ts
export type StringNullableListFilter = {
  equals?: Enumerable<string> | null
  has?: string | null
  hasEvery?: Enumerable<string>
  hasSome?: Enumerable<string>
  isEmpty?: boolean
}
```

```ts file=index.d.ts
export type BoolNullableListFilter = {
  equals?: Enumerable<boolean> | null
  has?: boolean | null
  hasEvery?: Enumerable<boolean>
  hasSome?: Enumerable<boolean>
  isEmpty?: boolean
}
```

### <inlinecode>has</inlinecode>

The given value exists in the list.

#### 例子

The following query returns all `Post` records where the `tags` list includes `"database"`:

```ts
const posts = await client.post.findMany({
  where: {
    tags: {
      has: 'databases',
    },
  },
})
```

The following query returns all `Post` records where the `tags` list **does not** include `"database"`:

```ts
const posts = await client.post.findMany({
  where: {
    NOT: {
      tags: {
        has: 'databases',
      },
    },
  },
})
```

### <inlinecode>hasEvery</inlinecode>

Every value exists in the list.

#### 例子

The following query returns all `Post` records where the `tags` list includes _at least_ `"database"` _and_ `"typescript"`:

```ts
const posts = await prisma.post.findMany({
  where: {
    tags: {
      hasEvery: ['databases', 'typescript'],
    },
  },
})
```

### <inlinecode>hasSome</inlinecode>

At least one value exists in the list.

#### 例子

The following query returns all `Post` records where the `tags` list `"database"` _or_ `"typescript"`:

```ts
const posts = await prisma.post.findMany({
  where: {
    tags: {
      hasSome: ['databases', 'typescript'],
    },
  },
})
```

### <inlinecode>isEmpty</inlinecode>

The list is empty.

#### 例子

The following query returns all `Post` records that have no tags:

```ts
const posts = await prisma.post.findMany({
  where: {
    tags: {
      isEmpty: true,
    },
  },
})
```

### <inlinecode>equals</inlinecode>

The list matches the given value exactly.

#### 例子

The following query returns all `Post` records where the `tags` list include `"database"` and `"typescript"` only:

```ts
const posts = await prisma.post.findMany({
  where: {
    tags: {
      equals: ['databases', 'typescript'],
    },
  },
})
```

## Atomic number operations

Atomic operations on update is available for number field types (`Float` and `Int`). This feature allows you to update a field based on its **current** value (such as _subtracting_ or _dividing_) without risking a race condition.

<details><summary>Overview: Race conditions</summary>

A race conditions occurs when two or more operations must be done in sequence in order to complete a task. In the following example, two clients try to increase the same field (`postCount`) by one:

| Client   | Operation           | Value  |
| :------- | :------------------ | :----- |
| Client 1 | **Get** field value | `21`   |
| Client 2 | **Get** field value | `21`   |
| Client 2 | **Set** field value | `22`   |
| Client 1 | **Set** field value | `22` ✘ |

The value _should_ be `23`, but the two clients did not read and write to the `postCount` field in sequence. Atomic operations on update combine read and write into a single operation, which prevents a race condition:

| Client   | Operation                   | Value              |
| :------- | :-------------------------- | :----------------- |
| Client 1 | **Get and set** field value | `21` &rarr; `22`   |
| Client 2 | **Get and set** field value | `22` &rarr; `23` ✔ |

</details>

### Operators

| Option      | Description                                                   |
| :---------- | :------------------------------------------------------------ |
| `increment` | Adds `n` to the current value.                                |
| `decrement` | Subtacts `n` from the current value.                          |
| `multiply`  | Multiplies the current value by `n`.                          |
| `divide`    | Divides the current value by `n`.                             |
| `set`       | Sets the current field value. Identical to `{ myField : n }`. |

### Reference

```ts file=index.d.ts
export type IntFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}
```

### Remarks

- You can only perform **one** atomic update per field, per query.
- If a field is `null`, it will not be updated by `increment`, `decrement`, `multiply`, or `divide`.

### 例子

#### Increment all `view` and `likes` fields of all `Post` records by `1`

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: {
      increment: 1,
    },
    likes: {
      increment: 1,
    },
  },
})
```

#### Set all `count` fields of all `Post` records to `0`

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: {
      set: 0,
    },
  },
})
```

Can also be written as:

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: 0,
  },
})
```

## <inlinecode>JSON</inlinecode> filters

For use cases and advanced examples, see: [Working with `Json` fields](../../../concepts/components/prisma-client/working-with-fields/working-with-json-fields) <span class="concepts"></span>

Advanced `Json` filtering is available as a Preview feature in [2.23.0 and later](https://github.com/prisma/prisma/releases/tag/2.23.0). In earlier versions, you can [filter on the exact `Json` field value](../../../concepts/components/prisma-client/working-with-fields/working-with-json-fields#filter-on-exact-field-value).

To enable advanced filtering, add `filterJson` to `previewFeatures` in your schema:

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["filterJson"]
}
```

<Admonition type="warning">

Supported by [PostgreSQL](../../../concepts/database-connectors/postgresql) <span class="concept"></span> and [MySQL](../../../concepts/database-connectors/mysql) <span class="concept"></span> with different syntaxes for the `path` option. PostgreSQL does not support filtering on object key values in arrays.

</Admonition>

The examples in this section assumes that the value of the `pet` field is:

```json
{
  "favorites": {
    "catBreed": "Turkish van",
    "dogBreed": "Rottweiler",
    "sanctuaries": ["RSPCA", "Alley Cat Allies"],
    "treats": [
      { "name": "Dreamies", "manufacturer": "Mars Inc"}
      { "name": "Treatos", "manufacturer": "The Dog People"}
    ]
  },
  "fostered": {
    "cats": ["Bob", "Alice", "Svetlana the Magnificent", "Queenie"]
  },
  "owned": {
    "cats": ["Elliott"]
  }
}
```

### Remarks

- The implementation of JSON filtering [differs between database connectors](../../../concepts/components/prisma-client/working-with-fields/working-with-json-fields)
- Filtering is case sensitive in PostgreSQL and does not yet support `mode`

### <inlinecode>path</inlinecode>

`path` represents the location of a specific key. The following query returns all users where the nested `favourites` > `dogBreed` key equals `"Rottweiler"`.

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['favorites', 'dogBreed'],
      equals: 'Rottweiler',
    },
  },
})
```

</tab>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.favorites.dogBreed',
      equals: 'Rottweiler',
    },
  },
})
```

</tab>
</TabbedContent>

The following query returns all users where the nested `owned` > `cats` array contains `"Elliott"`.

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['owned', 'cats'],
      array_contains: ['Elliott'],
    },
  },
})
```

</tab>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.owned.cats',
      array_contains: 'Elliott',
    },
  },
})
```

</tab>
</TabbedContent>

<Admonition type="warning">

Filtering by the key values of objects inside an array (below) is only supported by the MySQL connector.

</Admonition>

The following query returns all users where the nested `favorites` > `treats` array contains an object where the `name` value is `"Dreamies"`:

<TabbedContent tabs={[<FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.favorites.treats[*].name',
      array_contains: 'Dreamies',
    },
  },
})
```

</tab>

<tab>

</tab>

</TabbedContent>

### <inlinecode>string_contains</inlinecode>

The following query returns all users where the nested `favorites` > `catBreed` key value contains `"Van"`:

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['favorites', 'catBreed'],
      string_contains: 'Van',
    },
  },
})
```

</tab>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.favorites.catBreed',
      string_contains: 'Van',
    },
  },
})
```

</tab>

</TabbedContent>

### <inlinecode>string_starts_with</inlinecode>

The following query returns all users where the nested `favorites` > `catBreed` key value starts with `"Turkish"`:

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['favorites', 'catBreed'],
      string_starts_with: 'Turkish',
    },
  },
})
```

</tab>

<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.favorites.catBreed',
      string_starts_with: 'Turkish',
    },
  },
})
```

</tab>

</TabbedContent>

### <inlinecode>string_ends_with</inlinecode>

The following query returns all users where the nested `favorites` > `catBreed` key value ends with `"Van"`:

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['favorites', 'catBreed'],
      string_ends_with: 'Van',
    },
  },
})
```

</tab>

<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.favorites.catBreed',
      string_ends_with: 'Van',
    },
  },
})
```

</tab>

</TabbedContent>

### <inlinecode>array_contains</inlinecode>

The following query returns all users where the `sanctuaries` array contains the value `"RSPCA"`:

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['sanctuaries'],
      array_contains: ['RSPCA'],
    },
  },
})
```

<Admonition type="info">

**Note**: In PostgresSQL, the value of `array_contains` must be an array and not a string, even if the array only contains a single value.

</Admonition>

</tab>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.sanctuaries',
      array_contains: 'RSPCA',
    },
  },
})
```

</tab>
</TabbedContent>

The following query returns all users where the `sanctuaries` array contains _all_ the values in the given array:

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['sanctuaries'],
      array_contains: ['RSPCA', 'Alley Cat Allies'],
    },
  },
})
```

</tab>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.sanctuaries',
      array_contains: ['RSPCA', 'Alley Cat Allies'],
    },
  },
})
```

</tab>
</TabbedContent>

### <inlinecode>array_starts_with</inlinecode>

The following query returns all users where the `sanctuaries` array starts with the value `"RSPCA"`:

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['sanctuaries'],
      array_starts_with: ['RSPCA'],
    },
  },
})
```

<Admonition type="info">

**Note**: In PostgresSQL, the value of `array_starts_with` must be an array and not a string, even if the array only contains a single value.

</Admonition>

</tab>

<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.sanctuaries',
      array_starts_with: 'RSPCA',
    },
  },
})
```

</tab>
</TabbedContent>

### <inlinecode>array_ends_with</inlinecode>

The following query returns all users where the `sanctuaries` array ends with the value `"Alley Cat Allies"`:

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['sanctuaries'],
      array_ends_with: ['Alley Cat Allies'],
    },
  },
})
```

<Admonition type="info">

**Note**: In PostgresSQL, the value of `array_ends_with` must be an array and not a string, even if the array only contains a single value.

</Admonition>

</tab>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.sanctuaries',
      array_ends_with: 'Alley Cat Allies',
    },
  },
})
```

</tab>
</TabbedContent>

## Client methods

Client-level methods are prefixed by `$`.

<!-- prettier-ignore -->
### <inlinecode>$disconnect()</inlinecode>

The `$disconnect()` method closes the database connections that were established when `$connect` was called and stops the process that was running Prisma's query engine. See [Connection management](../../..//concepts/components/prisma-client/working-with-prismaclient/connection-management) for an overview of `$connect()` and `$disconnect()`.

#### Remarks

- `$disconnect()` returns a `Promise`, so you should call it inside an `async` function with the `await` keyword.

#### 参考

```ts
$disconnect(): Promise<void>
```

<!-- prettier-ignore -->
### <inlinecode>$connect()</inlinecode>

The `$connect()` method establishes a physical connection to the database via Prisma's query engine. See [Connection management](../../..//concepts/components/prisma-client/working-with-prismaclient/connection-management) for an overview of `$connect()` and `$disconnect()`.

#### Remarks

- `$connect()` returns a `Promise`, so you should call it inside an `async` function with the `await` keyword.

#### 参考

```ts
$connect(): Promise<void>
```

<!-- prettier-ignore -->
### <inlinecode>$on()</inlinecode>

The `$on()` method allows you to subscribe to events. With those you can subscribe to [logging events](#log) or the [exit hook](../../../concepts/components/prisma-client/working-with-prismaclient/connection-management#exit-hooks).

<!-- prettier-ignore -->
### <inlinecode>$use()</inlinecode>

The `$use()` method adds [middleware](../../../concepts/components/prisma-client/middleware) <span class="concept"></span>:

```ts
prisma.$use(async (params, next) => {
  console.log('This is middleware!')
  // Modify or interrogate params here

  return next(params)
})
```

#### <inlinecode>next</inlinecode>

`next` represents the "next level" in the middleware stack, which could be the next middleware or the Prisma Query, depending on [where in the stack you are](../../concepts/components/prisma-client/middleware#running-order-and-the-middleware-stack).

#### <inlinecode>params</inlinecode>

`params` is an object with information to use in your middleware.

| Parameter          | Description                                                                                                    |
| :----------------- | :------------------------------------------------------------------------------------------------------------- |
| `action`           | The query type - for example, `create` or `findMany`.                                                          |
| `args`             | Arguments that were passed into the query - for example, `where`, `data`, or `orderBy`                         |
| `dataPath`         | Populated if you use the [fluent API](../../../concepts/components/prisma-client/relation-queries#fluent-api). |
| `model`            | The model type - for example, `Post` or `User`.                                                                |
| `runInTransaction` | Returns `true` if the query ran in the context of a [transaction](#transaction).                               |

<Tip>

If you need the `model` property as a string, use: `String(params.model)`

</Tip>

Example parameter values:

```js
{
  args: { where: { id: 15 } },
  dataPath: [ 'select', 'author', 'select', 'posts' ],
  runInTransaction: false,
  action: 'findMany',
  model: 'Post'
}
```

#### 参考

`params` accepts the following type:

```ts file=index.d.ts
export type MiddlewareParams = {
  model?: ModelName
  action: PrismaAction
  args: any
  dataPath: string[]
  runInTransaction: boolean
}

export declare const ModelName: {
  User: 'User'
  Post: 'Post'
}

export declare type ModelName = typeof ModelName[keyof typeof ModelName]
```

#### 例子

See [middleware examples](../../../concepts/components/prisma-client/middleware#examples) <span class="concept"></span>.

<!-- prettier-ignore -->
### <inlinecode>$executeRaw()</inlinecode>

See: [Raw database access (`$executeRaw()`)](../../../concepts/components/prisma-client/raw-database-access#executeRaw).

<!-- prettier-ignore -->
### <inlinecode>$queryRaw()</inlinecode>

See: [Raw database access (`$queryRaw()`)](../../../concepts/components/prisma-client/raw-database-access#queryRaw).

<!-- prettier-ignore -->
### <inlinecode>$transaction()</inlinecode>

See: [Transactions](../../../concepts/components/prisma-client/transactions).

## Utility types

Utility types are helper functions and types that live on the Prisma namespace. They are useful for keeping your application type safe.

### <inlinecode>Prisma.validator</inlinecode>

The `validator` helps you create re-usable query parameters based on your schema models while making sure that the objects you create are valid. See also: [Using `Prisma.validator`](../../concepts/components/prisma-client/advanced-type-safety/prisma-validator) <span class="concept"></span>

#### 参考

```ts
export function validator<V>(): <S>(select: Exact<S, V>) => S

type Exact<A, W = unknown> = W extends unknown
  ? A extends Narrowable
    ? Cast<A, W>
    : Cast<
        { [K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never },
        { [K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K] }
      >
  : never

type Narrowable = string | number | boolean | bigint

type Cast<A, B> = A extends B ? A : B

export const type: unique symbol
```

#### 例子

The following example shows how you can extract a `create` operation into a custom function for re-use and accepting form data:

```ts
import { Prisma } from '@prisma/client'

const createUserAndPost = (
  name: string,
  email: string,
  postTitle: string,
  profileBio: string
) => {
  return Prisma.validator<Prisma.UserCreateInput>()({
    name,
    email,
    posts: {
      create: {
        title: postTitle,
      },
    },
    profile: {
      create: {
        bio: profileBio,
      },
    },
  })
}
```
